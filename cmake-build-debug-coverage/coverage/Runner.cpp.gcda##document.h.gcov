        -:    0:Source:/mnt/c/CLionProjects/21s-srch-eng-csphalopods/include/rapidjson/document.h
        -:    0:Graph:/mnt/c/CLionProjects/21s-srch-eng-csphalopods/cmake-build-debug-coverage/CMakeFiles/search_engine.dir/Runner.cpp.gcno
        -:    0:Data:/mnt/c/CLionProjects/21s-srch-eng-csphalopods/cmake-build-debug-coverage/CMakeFiles/search_engine.dir/Runner.cpp.gcda
        -:    0:Runs:1
        -:    1:// Tencent is pleased to support the open source community by making RapidJSON available.
        -:    2:// 
        -:    3:// Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip.
        -:    4://
        -:    5:// Licensed under the MIT License (the "License"); you may not use this file except
        -:    6:// in compliance with the License. You may obtain a copy of the License at
        -:    7://
        -:    8:// http://opensource.org/licenses/MIT
        -:    9://
        -:   10:// Unless required by applicable law or agreed to in writing, software distributed 
        -:   11:// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR 
        -:   12:// CONDITIONS OF ANY KIND, either express or implied. See the License for the 
        -:   13:// specific language governing permissions and limitations under the License.
        -:   14:
        -:   15:#ifndef RAPIDJSON_DOCUMENT_H_
        -:   16:#define RAPIDJSON_DOCUMENT_H_
        -:   17:
        -:   18:/*! \file document.h */
        -:   19:
        -:   20:#include "reader.h"
        -:   21:#include "internal/meta.h"
        -:   22:#include "internal/strfunc.h"
        -:   23:#include "memorystream.h"
        -:   24:#include "encodedstream.h"
        -:   25:#include <new>      // placement new
        -:   26:#include <limits>
        -:   27:#ifdef __cpp_lib_three_way_comparison
        -:   28:#include <compare>
        -:   29:#endif
        -:   30:
        -:   31:RAPIDJSON_DIAG_PUSH
        -:   32:#ifdef __clang__
        -:   33:RAPIDJSON_DIAG_OFF(padded)
        -:   34:RAPIDJSON_DIAG_OFF(switch-enum)
        -:   35:RAPIDJSON_DIAG_OFF(c++98-compat)
        -:   36:#elif defined(_MSC_VER)
        -:   37:RAPIDJSON_DIAG_OFF(4127) // conditional expression is constant
        -:   38:RAPIDJSON_DIAG_OFF(4244) // conversion from kXxxFlags to 'uint16_t', possible loss of data
        -:   39:#endif
        -:   40:
        -:   41:#ifdef __GNUC__
        -:   42:RAPIDJSON_DIAG_OFF(effc++)
        -:   43:#endif // __GNUC__
        -:   44:
        -:   45:#ifndef RAPIDJSON_NOMEMBERITERATORCLASS
        -:   46:#include <iterator> // std::random_access_iterator_tag
        -:   47:#endif
        -:   48:
        -:   49:#if RAPIDJSON_USE_MEMBERSMAP
        -:   50:#include <map> // std::multimap
        -:   51:#endif
        -:   52:
        -:   53:RAPIDJSON_NAMESPACE_BEGIN
        -:   54:
        -:   55:// Forward declaration.
        -:   56:template <typename Encoding, typename Allocator>
        -:   57:class GenericValue;
        -:   58:
        -:   59:template <typename Encoding, typename Allocator, typename StackAllocator>
        -:   60:class GenericDocument;
        -:   61:
        -:   62:/*! \def RAPIDJSON_DEFAULT_ALLOCATOR
        -:   63:    \ingroup RAPIDJSON_CONFIG
        -:   64:    \brief Allows to choose default allocator.
        -:   65:
        -:   66:    User can define this to use CrtAllocator or MemoryPoolAllocator.
        -:   67:*/
        -:   68:#ifndef RAPIDJSON_DEFAULT_ALLOCATOR
        -:   69:#define RAPIDJSON_DEFAULT_ALLOCATOR MemoryPoolAllocator<CrtAllocator>
        -:   70:#endif
        -:   71:
        -:   72:/*! \def RAPIDJSON_DEFAULT_STACK_ALLOCATOR
        -:   73:    \ingroup RAPIDJSON_CONFIG
        -:   74:    \brief Allows to choose default stack allocator for Document.
        -:   75:
        -:   76:    User can define this to use CrtAllocator or MemoryPoolAllocator.
        -:   77:*/
        -:   78:#ifndef RAPIDJSON_DEFAULT_STACK_ALLOCATOR
        -:   79:#define RAPIDJSON_DEFAULT_STACK_ALLOCATOR CrtAllocator
        -:   80:#endif
        -:   81:
        -:   82:/*! \def RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY
        -:   83:    \ingroup RAPIDJSON_CONFIG
        -:   84:    \brief User defined kDefaultObjectCapacity value.
        -:   85:
        -:   86:    User can define this as any natural number.
        -:   87:*/
        -:   88:#ifndef RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY
        -:   89:// number of objects that rapidjson::Value allocates memory for by default
        -:   90:#define RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY 16
        -:   91:#endif
        -:   92:
        -:   93:/*! \def RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY
        -:   94:    \ingroup RAPIDJSON_CONFIG
        -:   95:    \brief User defined kDefaultArrayCapacity value.
        -:   96:
        -:   97:    User can define this as any natural number.
        -:   98:*/
        -:   99:#ifndef RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY
        -:  100:// number of array elements that rapidjson::Value allocates memory for by default
        -:  101:#define RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY 16
        -:  102:#endif
        -:  103:
        -:  104://! Name-value pair in a JSON object value.
        -:  105:/*!
        -:  106:    This class was internal to GenericValue. It used to be a inner struct.
        -:  107:    But a compiler (IBM XL C/C++ for AIX) have reported to have problem with that so it moved as a namespace scope struct.
        -:  108:    https://code.google.com/p/rapidjson/issues/detail?id=64
        -:  109:*/
        -:  110:template <typename Encoding, typename Allocator> 
        -:  111:class GenericMember {
        -:  112:public:
        -:  113:    GenericValue<Encoding, Allocator> name;     //!< name of member (must be a string)
        -:  114:    GenericValue<Encoding, Allocator> value;    //!< value of member.
        -:  115:
        -:  116:#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -:  117:    //! Move constructor in C++11
        -:  118:    GenericMember(GenericMember&& rhs) RAPIDJSON_NOEXCEPT
        -:  119:        : name(std::move(rhs.name)),
        -:  120:          value(std::move(rhs.value))
        -:  121:    {
        -:  122:    }
        -:  123:
        -:  124:    //! Move assignment in C++11
        -:  125:    GenericMember& operator=(GenericMember&& rhs) RAPIDJSON_NOEXCEPT {
        -:  126:        return *this = static_cast<GenericMember&>(rhs);
        -:  127:    }
        -:  128:#endif
        -:  129:
        -:  130:    //! Assignment with move semantics.
        -:  131:    /*! \param rhs Source of the assignment. Its name and value will become a null value after assignment.
        -:  132:    */
        -:  133:    GenericMember& operator=(GenericMember& rhs) RAPIDJSON_NOEXCEPT {
        -:  134:        if (RAPIDJSON_LIKELY(this != &rhs)) {
        -:  135:            name = rhs.name;
        -:  136:            value = rhs.value;
        -:  137:        }
        -:  138:        return *this;
        -:  139:    }
        -:  140:
        -:  141:    // swap() for std::sort() and other potential use in STL.
        -:  142:    friend inline void swap(GenericMember& a, GenericMember& b) RAPIDJSON_NOEXCEPT {
        -:  143:        a.name.Swap(b.name);
        -:  144:        a.value.Swap(b.value);
        -:  145:    }
        -:  146:
        -:  147:private:
        -:  148:    //! Copy constructor is not permitted.
        -:  149:    GenericMember(const GenericMember& rhs);
        -:  150:};
        -:  151:
        -:  152:///////////////////////////////////////////////////////////////////////////////
        -:  153:// GenericMemberIterator
        -:  154:
        -:  155:#ifndef RAPIDJSON_NOMEMBERITERATORCLASS
        -:  156:
        -:  157://! (Constant) member iterator for a JSON object value
        -:  158:/*!
        -:  159:    \tparam Const Is this a constant iterator?
        -:  160:    \tparam Encoding    Encoding of the value. (Even non-string values need to have the same encoding in a document)
        -:  161:    \tparam Allocator   Allocator type for allocating memory of object, array and string.
        -:  162:
        -:  163:    This class implements a Random Access Iterator for GenericMember elements
        -:  164:    of a GenericValue, see ISO/IEC 14882:2003(E) C++ standard, 24.1 [lib.iterator.requirements].
        -:  165:
        -:  166:    \note This iterator implementation is mainly intended to avoid implicit
        -:  167:        conversions from iterator values to \c NULL,
        -:  168:        e.g. from GenericValue::FindMember.
        -:  169:
        -:  170:    \note Define \c RAPIDJSON_NOMEMBERITERATORCLASS to fall back to a
        -:  171:        pointer-based implementation, if your platform doesn't provide
        -:  172:        the C++ <iterator> header.
        -:  173:
        -:  174:    \see GenericMember, GenericValue::MemberIterator, GenericValue::ConstMemberIterator
        -:  175: */
        -:  176:template <bool Const, typename Encoding, typename Allocator>
        -:  177:class GenericMemberIterator {
        -:  178:
        -:  179:    friend class GenericValue<Encoding,Allocator>;
        -:  180:    template <bool, typename, typename> friend class GenericMemberIterator;
        -:  181:
        -:  182:    typedef GenericMember<Encoding,Allocator> PlainType;
        -:  183:    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
        -:  184:
        -:  185:public:
        -:  186:    //! Iterator type itself
        -:  187:    typedef GenericMemberIterator Iterator;
        -:  188:    //! Constant iterator type
        -:  189:    typedef GenericMemberIterator<true,Encoding,Allocator>  ConstIterator;
        -:  190:    //! Non-constant iterator type
        -:  191:    typedef GenericMemberIterator<false,Encoding,Allocator> NonConstIterator;
        -:  192:
        -:  193:    /** \name std::iterator_traits support */
        -:  194:    //@{
        -:  195:    typedef ValueType      value_type;
        -:  196:    typedef ValueType *    pointer;
        -:  197:    typedef ValueType &    reference;
        -:  198:    typedef std::ptrdiff_t difference_type;
        -:  199:    typedef std::random_access_iterator_tag iterator_category;
        -:  200:    //@}
        -:  201:
        -:  202:    //! Pointer to (const) GenericMember
        -:  203:    typedef pointer         Pointer;
        -:  204:    //! Reference to (const) GenericMember
        -:  205:    typedef reference       Reference;
        -:  206:    //! Signed integer type (e.g. \c ptrdiff_t)
        -:  207:    typedef difference_type DifferenceType;
        -:  208:
        -:  209:    //! Default constructor (singular value)
        -:  210:    /*! Creates an iterator pointing to no element.
        -:  211:        \note All operations, except for comparisons, are undefined on such values.
        -:  212:     */
        -:  213:    GenericMemberIterator() : ptr_() {}
        -:  214:
        -:  215:    //! Iterator conversions to more const
        -:  216:    /*!
        -:  217:        \param it (Non-const) iterator to copy from
        -:  218:
        -:  219:        Allows the creation of an iterator from another GenericMemberIterator
        -:  220:        that is "less const".  Especially, creating a non-constant iterator
        -:  221:        from a constant iterator are disabled:
        -:  222:        \li const -> non-const (not ok)
        -:  223:        \li const -> const (ok)
        -:  224:        \li non-const -> const (ok)
        -:  225:        \li non-const -> non-const (ok)
        -:  226:
        -:  227:        \note If the \c Const template parameter is already \c false, this
        -:  228:            constructor effectively defines a regular copy-constructor.
        -:  229:            Otherwise, the copy constructor is implicitly defined.
        -:  230:    */
        -:  231:    GenericMemberIterator(const NonConstIterator & it) : ptr_(it.ptr_) {}
        -:  232:    Iterator& operator=(const NonConstIterator & it) { ptr_ = it.ptr_; return *this; }
        -:  233:
        -:  234:    //! @name stepping
        -:  235:    //@{
function _ZN9rapidjson21GenericMemberIteratorILb0ENS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEppEv called 200 returned 100% blocks executed 100%
      200:  236:    Iterator& operator++(){ ++ptr_; return *this; }
      200:  236-block  0
        -:  237:    Iterator& operator--(){ --ptr_; return *this; }
        -:  238:    Iterator  operator++(int){ Iterator old(*this); ++ptr_; return old; }
        -:  239:    Iterator  operator--(int){ Iterator old(*this); --ptr_; return old; }
        -:  240:    //@}
        -:  241:
        -:  242:    //! @name increment/decrement
        -:  243:    //@{
        -:  244:    Iterator operator+(DifferenceType n) const { return Iterator(ptr_+n); }
        -:  245:    Iterator operator-(DifferenceType n) const { return Iterator(ptr_-n); }
        -:  246:
        -:  247:    Iterator& operator+=(DifferenceType n) { ptr_+=n; return *this; }
        -:  248:    Iterator& operator-=(DifferenceType n) { ptr_-=n; return *this; }
        -:  249:    //@}
        -:  250:
        -:  251:    //! @name relations
        -:  252:    //@{
        -:  253:    template <bool Const_> bool operator==(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ == that.ptr_; }
function _ZNK9rapidjson21GenericMemberIteratorILb0ENS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEneILb0EEEbRKNS0_IXT_ES2_S5_EE called 698 returned 100% blocks executed 100%
      698:  254:    template <bool Const_> bool operator!=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ != that.ptr_; }
      698:  254-block  0
        -:  255:    template <bool Const_> bool operator<=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ <= that.ptr_; }
        -:  256:    template <bool Const_> bool operator>=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ >= that.ptr_; }
        -:  257:    template <bool Const_> bool operator< (const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ < that.ptr_; }
        -:  258:    template <bool Const_> bool operator> (const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ > that.ptr_; }
        -:  259:
        -:  260:#ifdef __cpp_lib_three_way_comparison
        -:  261:    template <bool Const_> std::strong_ordering operator<=>(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ <=> that.ptr_; }
        -:  262:#endif
        -:  263:    //@}
        -:  264:
        -:  265:    //! @name dereference
        -:  266:    //@{
        -:  267:    Reference operator*() const { return *ptr_; }
function _ZNK9rapidjson21GenericMemberIteratorILb0ENS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEptEv called 698 returned 100% blocks executed 100%
      698:  268:    Pointer   operator->() const { return ptr_; }
      698:  268-block  0
        -:  269:    Reference operator[](DifferenceType n) const { return ptr_[n]; }
        -:  270:    //@}
        -:  271:
        -:  272:    //! Distance
        -:  273:    DifferenceType operator-(ConstIterator that) const { return ptr_-that.ptr_; }
        -:  274:
        -:  275:private:
        -:  276:    //! Internal constructor from plain pointer
function _ZN9rapidjson21GenericMemberIteratorILb0ENS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2EPNS_13GenericMemberIS2_S5_EE called 947 returned 100% blocks executed 100%
      947:  277:    explicit GenericMemberIterator(Pointer p) : ptr_(p) {}
        -:  278:
        -:  279:    Pointer ptr_; //!< raw pointer
        -:  280:};
        -:  281:
        -:  282:#else // RAPIDJSON_NOMEMBERITERATORCLASS
        -:  283:
        -:  284:// class-based member iterator implementation disabled, use plain pointers
        -:  285:
        -:  286:template <bool Const, typename Encoding, typename Allocator>
        -:  287:class GenericMemberIterator;
        -:  288:
        -:  289://! non-const GenericMemberIterator
        -:  290:template <typename Encoding, typename Allocator>
        -:  291:class GenericMemberIterator<false,Encoding,Allocator> {
        -:  292:public:
        -:  293:    //! use plain pointer as iterator type
        -:  294:    typedef GenericMember<Encoding,Allocator>* Iterator;
        -:  295:};
        -:  296://! const GenericMemberIterator
        -:  297:template <typename Encoding, typename Allocator>
        -:  298:class GenericMemberIterator<true,Encoding,Allocator> {
        -:  299:public:
        -:  300:    //! use plain const pointer as iterator type
        -:  301:    typedef const GenericMember<Encoding,Allocator>* Iterator;
        -:  302:};
        -:  303:
        -:  304:#endif // RAPIDJSON_NOMEMBERITERATORCLASS
        -:  305:
        -:  306:///////////////////////////////////////////////////////////////////////////////
        -:  307:// GenericStringRef
        -:  308:
        -:  309://! Reference to a constant string (not taking a copy)
        -:  310:/*!
        -:  311:    \tparam CharType character type of the string
        -:  312:
        -:  313:    This helper class is used to automatically infer constant string
        -:  314:    references for string literals, especially from \c const \b (!)
        -:  315:    character arrays.
        -:  316:
        -:  317:    The main use is for creating JSON string values without copying the
        -:  318:    source string via an \ref Allocator.  This requires that the referenced
        -:  319:    string pointers have a sufficient lifetime, which exceeds the lifetime
        -:  320:    of the associated GenericValue.
        -:  321:
        -:  322:    \b Example
        -:  323:    \code
        -:  324:    Value v("foo");   // ok, no need to copy & calculate length
        -:  325:    const char foo[] = "foo";
        -:  326:    v.SetString(foo); // ok
        -:  327:
        -:  328:    const char* bar = foo;
        -:  329:    // Value x(bar); // not ok, can't rely on bar's lifetime
        -:  330:    Value x(StringRef(bar)); // lifetime explicitly guaranteed by user
        -:  331:    Value y(StringRef(bar, 3));  // ok, explicitly pass length
        -:  332:    \endcode
        -:  333:
        -:  334:    \see StringRef, GenericValue::SetString
        -:  335:*/
        -:  336:template<typename CharType>
        -:  337:struct GenericStringRef {
        -:  338:    typedef CharType Ch; //!< character type of the string
        -:  339:
        -:  340:    //! Create string reference from \c const character array
        -:  341:#ifndef __clang__ // -Wdocumentation
        -:  342:    /*!
        -:  343:        This constructor implicitly creates a constant string reference from
        -:  344:        a \c const character array.  It has better performance than
        -:  345:        \ref StringRef(const CharType*) by inferring the string \ref length
        -:  346:        from the array length, and also supports strings containing null
        -:  347:        characters.
        -:  348:
        -:  349:        \tparam N length of the string, automatically inferred
        -:  350:
        -:  351:        \param str Constant character array, lifetime assumed to be longer
        -:  352:            than the use of the string in e.g. a GenericValue
        -:  353:
        -:  354:        \post \ref s == str
        -:  355:
        -:  356:        \note Constant complexity.
        -:  357:        \note There is a hidden, private overload to disallow references to
        -:  358:            non-const character arrays to be created via this constructor.
        -:  359:            By this, e.g. function-scope arrays used to be filled via
        -:  360:            \c snprintf are excluded from consideration.
        -:  361:            In such cases, the referenced string should be \b copied to the
        -:  362:            GenericValue instead.
        -:  363:     */
        -:  364:#endif
        -:  365:    template<SizeType N>
        -:  366:    GenericStringRef(const CharType (&str)[N]) RAPIDJSON_NOEXCEPT
        -:  367:        : s(str), length(N-1) {}
        -:  368:
        -:  369:    //! Explicitly create string reference from \c const character pointer
        -:  370:#ifndef __clang__ // -Wdocumentation
        -:  371:    /*!
        -:  372:        This constructor can be used to \b explicitly  create a reference to
        -:  373:        a constant string pointer.
        -:  374:
        -:  375:        \see StringRef(const CharType*)
        -:  376:
        -:  377:        \param str Constant character pointer, lifetime assumed to be longer
        -:  378:            than the use of the string in e.g. a GenericValue
        -:  379:
        -:  380:        \post \ref s == str
        -:  381:
        -:  382:        \note There is a hidden, private overload to disallow references to
        -:  383:            non-const character arrays to be created via this constructor.
        -:  384:            By this, e.g. function-scope arrays used to be filled via
        -:  385:            \c snprintf are excluded from consideration.
        -:  386:            In such cases, the referenced string should be \b copied to the
        -:  387:            GenericValue instead.
        -:  388:     */
        -:  389:#endif
function _ZN9rapidjson16GenericStringRefIcEC2EPKc called 249 returned 100% blocks executed 100%
      249:  390:    explicit GenericStringRef(const CharType* str)
      249:  391:        : s(str), length(NotNullStrLen(str)) {}
      249:  391-block  0
call    0 returned 249
        -:  392:
        -:  393:    //! Create constant string reference from pointer and length
        -:  394:#ifndef __clang__ // -Wdocumentation
        -:  395:    /*! \param str constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue
        -:  396:        \param len length of the string, excluding the trailing NULL terminator
        -:  397:
        -:  398:        \post \ref s == str && \ref length == len
        -:  399:        \note Constant complexity.
        -:  400:     */
        -:  401:#endif
function _ZN9rapidjson16GenericStringRefIcEC2EPKcj called 12824 returned 100% blocks executed 57%
    12824:  402:    GenericStringRef(const CharType* str, SizeType len)
   12824*:  403:        : s(RAPIDJSON_LIKELY(str) ? str : emptyString), length(len) { RAPIDJSON_ASSERT(str != 0 || len == 0u); }
    12824:  403-block  0
branch  0 taken 12824 (fallthrough)
branch  1 taken 0
    12824:  403-block  1
    %%%%%:  403-block  2
    12824:  403-block  3
branch  2 taken 0 (fallthrough)
branch  3 taken 12824
    %%%%%:  403-block  4
branch  4 never executed
branch  5 never executed
    %%%%%:  403-block  5
call    6 never executed
        -:  404:
function _ZN9rapidjson16GenericStringRefIcEC2ERKS1_ called 249 returned 100% blocks executed 100%
      249:  405:    GenericStringRef(const GenericStringRef& rhs) : s(rhs.s), length(rhs.length) {}
        -:  406:
        -:  407:    //! implicit conversion to plain CharType pointer
function _ZNK9rapidjson16GenericStringRefIcEcvPKcEv called 13073 returned 100% blocks executed 100%
    13073:  408:    operator const Ch *() const { return s; }
    13073:  408-block  0
        -:  409:
        -:  410:    const Ch* const s; //!< plain CharType pointer
        -:  411:    const SizeType length; //!< length of the string (excluding the trailing NULL terminator)
        -:  412:
        -:  413:private:
function _ZN9rapidjson16GenericStringRefIcE13NotNullStrLenEPKc called 249 returned 100% blocks executed 75%
      249:  414:    SizeType NotNullStrLen(const CharType* str) {
     249*:  415:        RAPIDJSON_ASSERT(str != 0);
      249:  415-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 249
    %%%%%:  415-block  1
call    2 never executed
      249:  416:        return internal::StrLen(str);
      249:  416-block  0
call    0 returned 249
        -:  417:    }
        -:  418:
        -:  419:    /// Empty string - used when passing in a NULL pointer
        -:  420:    static const Ch emptyString[];
        -:  421:
        -:  422:    //! Disallow construction from non-const array
        -:  423:    template<SizeType N>
        -:  424:    GenericStringRef(CharType (&str)[N]) /* = delete */;
        -:  425:    //! Copy assignment operator not permitted - immutable type
        -:  426:    GenericStringRef& operator=(const GenericStringRef& rhs) /* = delete */;
        -:  427:};
        -:  428:
        -:  429:template<typename CharType>
        -:  430:const CharType GenericStringRef<CharType>::emptyString[] = { CharType() };
        -:  431:
        -:  432://! Mark a character pointer as constant string
        -:  433:/*! Mark a plain character pointer as a "string literal".  This function
        -:  434:    can be used to avoid copying a character string to be referenced as a
        -:  435:    value in a JSON GenericValue object, if the string's lifetime is known
        -:  436:    to be valid long enough.
        -:  437:    \tparam CharType Character type of the string
        -:  438:    \param str Constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue
        -:  439:    \return GenericStringRef string reference object
        -:  440:    \relatesalso GenericStringRef
        -:  441:
        -:  442:    \see GenericValue::GenericValue(StringRefType), GenericValue::operator=(StringRefType), GenericValue::SetString(StringRefType), GenericValue::PushBack(StringRefType, Allocator&), GenericValue::AddMember
        -:  443:*/
        -:  444:template<typename CharType>
function _ZN9rapidjson9StringRefIcEENS_16GenericStringRefIT_EEPKS2_ called 249 returned 100% blocks executed 100%
      249:  445:inline GenericStringRef<CharType> StringRef(const CharType* str) {
      249:  446:    return GenericStringRef<CharType>(str);
      249:  446-block  0
call    0 returned 249
        -:  447:}
        -:  448:
        -:  449://! Mark a character pointer as constant string
        -:  450:/*! Mark a plain character pointer as a "string literal".  This function
        -:  451:    can be used to avoid copying a character string to be referenced as a
        -:  452:    value in a JSON GenericValue object, if the string's lifetime is known
        -:  453:    to be valid long enough.
        -:  454:
        -:  455:    This version has better performance with supplied length, and also
        -:  456:    supports string containing null characters.
        -:  457:
        -:  458:    \tparam CharType character type of the string
        -:  459:    \param str Constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue
        -:  460:    \param length The length of source string.
        -:  461:    \return GenericStringRef string reference object
        -:  462:    \relatesalso GenericStringRef
        -:  463:*/
        -:  464:template<typename CharType>
function _ZN9rapidjson9StringRefIcEENS_16GenericStringRefIT_EEPKS2_m called 12824 returned 100% blocks executed 100%
    12824:  465:inline GenericStringRef<CharType> StringRef(const CharType* str, size_t length) {
    12824:  466:    return GenericStringRef<CharType>(str, SizeType(length));
    12824:  466-block  0
call    0 returned 12824
        -:  467:}
        -:  468:
        -:  469:#if RAPIDJSON_HAS_STDSTRING
        -:  470://! Mark a string object as constant string
        -:  471:/*! Mark a string object (e.g. \c std::string) as a "string literal".
        -:  472:    This function can be used to avoid copying a string to be referenced as a
        -:  473:    value in a JSON GenericValue object, if the string's lifetime is known
        -:  474:    to be valid long enough.
        -:  475:
        -:  476:    \tparam CharType character type of the string
        -:  477:    \param str Constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue
        -:  478:    \return GenericStringRef string reference object
        -:  479:    \relatesalso GenericStringRef
        -:  480:    \note Requires the definition of the preprocessor symbol \ref RAPIDJSON_HAS_STDSTRING.
        -:  481:*/
        -:  482:template<typename CharType>
        -:  483:inline GenericStringRef<CharType> StringRef(const std::basic_string<CharType>& str) {
        -:  484:    return GenericStringRef<CharType>(str.data(), SizeType(str.size()));
        -:  485:}
        -:  486:#endif
        -:  487:
        -:  488:///////////////////////////////////////////////////////////////////////////////
        -:  489:// GenericValue type traits
        -:  490:namespace internal {
        -:  491:
        -:  492:template <typename T, typename Encoding = void, typename Allocator = void>
        -:  493:struct IsGenericValueImpl : FalseType {};
        -:  494:
        -:  495:// select candidates according to nested encoding and allocator types
        -:  496:template <typename T> struct IsGenericValueImpl<T, typename Void<typename T::EncodingType>::Type, typename Void<typename T::AllocatorType>::Type>
        -:  497:    : IsBaseOf<GenericValue<typename T::EncodingType, typename T::AllocatorType>, T>::Type {};
        -:  498:
        -:  499:// helper to match arbitrary GenericValue instantiations, including derived classes
        -:  500:template <typename T> struct IsGenericValue : IsGenericValueImpl<T>::Type {};
        -:  501:
        -:  502:} // namespace internal
        -:  503:
        -:  504:///////////////////////////////////////////////////////////////////////////////
        -:  505:// TypeHelper
        -:  506:
        -:  507:namespace internal {
        -:  508:
        -:  509:template <typename ValueType, typename T>
        -:  510:struct TypeHelper {};
        -:  511:
        -:  512:template<typename ValueType> 
        -:  513:struct TypeHelper<ValueType, bool> {
        -:  514:    static bool Is(const ValueType& v) { return v.IsBool(); }
        -:  515:    static bool Get(const ValueType& v) { return v.GetBool(); }
        -:  516:    static ValueType& Set(ValueType& v, bool data) { return v.SetBool(data); }
        -:  517:    static ValueType& Set(ValueType& v, bool data, typename ValueType::AllocatorType&) { return v.SetBool(data); }
        -:  518:};
        -:  519:
        -:  520:template<typename ValueType> 
        -:  521:struct TypeHelper<ValueType, int> {
        -:  522:    static bool Is(const ValueType& v) { return v.IsInt(); }
        -:  523:    static int Get(const ValueType& v) { return v.GetInt(); }
        -:  524:    static ValueType& Set(ValueType& v, int data) { return v.SetInt(data); }
        -:  525:    static ValueType& Set(ValueType& v, int data, typename ValueType::AllocatorType&) { return v.SetInt(data); }
        -:  526:};
        -:  527:
        -:  528:template<typename ValueType> 
        -:  529:struct TypeHelper<ValueType, unsigned> {
        -:  530:    static bool Is(const ValueType& v) { return v.IsUint(); }
        -:  531:    static unsigned Get(const ValueType& v) { return v.GetUint(); }
        -:  532:    static ValueType& Set(ValueType& v, unsigned data) { return v.SetUint(data); }
        -:  533:    static ValueType& Set(ValueType& v, unsigned data, typename ValueType::AllocatorType&) { return v.SetUint(data); }
        -:  534:};
        -:  535:
        -:  536:#ifdef _MSC_VER
        -:  537:RAPIDJSON_STATIC_ASSERT(sizeof(long) == sizeof(int));
        -:  538:template<typename ValueType>
        -:  539:struct TypeHelper<ValueType, long> {
        -:  540:    static bool Is(const ValueType& v) { return v.IsInt(); }
        -:  541:    static long Get(const ValueType& v) { return v.GetInt(); }
        -:  542:    static ValueType& Set(ValueType& v, long data) { return v.SetInt(data); }
        -:  543:    static ValueType& Set(ValueType& v, long data, typename ValueType::AllocatorType&) { return v.SetInt(data); }
        -:  544:};
        -:  545:
        -:  546:RAPIDJSON_STATIC_ASSERT(sizeof(unsigned long) == sizeof(unsigned));
        -:  547:template<typename ValueType>
        -:  548:struct TypeHelper<ValueType, unsigned long> {
        -:  549:    static bool Is(const ValueType& v) { return v.IsUint(); }
        -:  550:    static unsigned long Get(const ValueType& v) { return v.GetUint(); }
        -:  551:    static ValueType& Set(ValueType& v, unsigned long data) { return v.SetUint(data); }
        -:  552:    static ValueType& Set(ValueType& v, unsigned long data, typename ValueType::AllocatorType&) { return v.SetUint(data); }
        -:  553:};
        -:  554:#endif
        -:  555:
        -:  556:template<typename ValueType> 
        -:  557:struct TypeHelper<ValueType, int64_t> {
        -:  558:    static bool Is(const ValueType& v) { return v.IsInt64(); }
        -:  559:    static int64_t Get(const ValueType& v) { return v.GetInt64(); }
        -:  560:    static ValueType& Set(ValueType& v, int64_t data) { return v.SetInt64(data); }
        -:  561:    static ValueType& Set(ValueType& v, int64_t data, typename ValueType::AllocatorType&) { return v.SetInt64(data); }
        -:  562:};
        -:  563:
        -:  564:template<typename ValueType> 
        -:  565:struct TypeHelper<ValueType, uint64_t> {
        -:  566:    static bool Is(const ValueType& v) { return v.IsUint64(); }
        -:  567:    static uint64_t Get(const ValueType& v) { return v.GetUint64(); }
        -:  568:    static ValueType& Set(ValueType& v, uint64_t data) { return v.SetUint64(data); }
        -:  569:    static ValueType& Set(ValueType& v, uint64_t data, typename ValueType::AllocatorType&) { return v.SetUint64(data); }
        -:  570:};
        -:  571:
        -:  572:template<typename ValueType> 
        -:  573:struct TypeHelper<ValueType, double> {
        -:  574:    static bool Is(const ValueType& v) { return v.IsDouble(); }
        -:  575:    static double Get(const ValueType& v) { return v.GetDouble(); }
        -:  576:    static ValueType& Set(ValueType& v, double data) { return v.SetDouble(data); }
        -:  577:    static ValueType& Set(ValueType& v, double data, typename ValueType::AllocatorType&) { return v.SetDouble(data); }
        -:  578:};
        -:  579:
        -:  580:template<typename ValueType> 
        -:  581:struct TypeHelper<ValueType, float> {
        -:  582:    static bool Is(const ValueType& v) { return v.IsFloat(); }
        -:  583:    static float Get(const ValueType& v) { return v.GetFloat(); }
        -:  584:    static ValueType& Set(ValueType& v, float data) { return v.SetFloat(data); }
        -:  585:    static ValueType& Set(ValueType& v, float data, typename ValueType::AllocatorType&) { return v.SetFloat(data); }
        -:  586:};
        -:  587:
        -:  588:template<typename ValueType> 
        -:  589:struct TypeHelper<ValueType, const typename ValueType::Ch*> {
        -:  590:    typedef const typename ValueType::Ch* StringType;
        -:  591:    static bool Is(const ValueType& v) { return v.IsString(); }
        -:  592:    static StringType Get(const ValueType& v) { return v.GetString(); }
        -:  593:    static ValueType& Set(ValueType& v, const StringType data) { return v.SetString(typename ValueType::StringRefType(data)); }
        -:  594:    static ValueType& Set(ValueType& v, const StringType data, typename ValueType::AllocatorType& a) { return v.SetString(data, a); }
        -:  595:};
        -:  596:
        -:  597:#if RAPIDJSON_HAS_STDSTRING
        -:  598:template<typename ValueType> 
        -:  599:struct TypeHelper<ValueType, std::basic_string<typename ValueType::Ch> > {
        -:  600:    typedef std::basic_string<typename ValueType::Ch> StringType;
        -:  601:    static bool Is(const ValueType& v) { return v.IsString(); }
        -:  602:    static StringType Get(const ValueType& v) { return StringType(v.GetString(), v.GetStringLength()); }
        -:  603:    static ValueType& Set(ValueType& v, const StringType& data, typename ValueType::AllocatorType& a) { return v.SetString(data, a); }
        -:  604:};
        -:  605:#endif
        -:  606:
        -:  607:template<typename ValueType> 
        -:  608:struct TypeHelper<ValueType, typename ValueType::Array> {
        -:  609:    typedef typename ValueType::Array ArrayType;
        -:  610:    static bool Is(const ValueType& v) { return v.IsArray(); }
        -:  611:    static ArrayType Get(ValueType& v) { return v.GetArray(); }
        -:  612:    static ValueType& Set(ValueType& v, ArrayType data) { return v = data; }
        -:  613:    static ValueType& Set(ValueType& v, ArrayType data, typename ValueType::AllocatorType&) { return v = data; }
        -:  614:};
        -:  615:
        -:  616:template<typename ValueType> 
        -:  617:struct TypeHelper<ValueType, typename ValueType::ConstArray> {
        -:  618:    typedef typename ValueType::ConstArray ArrayType;
        -:  619:    static bool Is(const ValueType& v) { return v.IsArray(); }
        -:  620:    static ArrayType Get(const ValueType& v) { return v.GetArray(); }
        -:  621:};
        -:  622:
        -:  623:template<typename ValueType> 
        -:  624:struct TypeHelper<ValueType, typename ValueType::Object> {
        -:  625:    typedef typename ValueType::Object ObjectType;
        -:  626:    static bool Is(const ValueType& v) { return v.IsObject(); }
        -:  627:    static ObjectType Get(ValueType& v) { return v.GetObject(); }
        -:  628:    static ValueType& Set(ValueType& v, ObjectType data) { return v = data; }
        -:  629:    static ValueType& Set(ValueType& v, ObjectType data, typename ValueType::AllocatorType&) { return v = data; }
        -:  630:};
        -:  631:
        -:  632:template<typename ValueType> 
        -:  633:struct TypeHelper<ValueType, typename ValueType::ConstObject> {
        -:  634:    typedef typename ValueType::ConstObject ObjectType;
        -:  635:    static bool Is(const ValueType& v) { return v.IsObject(); }
        -:  636:    static ObjectType Get(const ValueType& v) { return v.GetObject(); }
        -:  637:};
        -:  638:
        -:  639:} // namespace internal
        -:  640:
        -:  641:// Forward declarations
        -:  642:template <bool, typename> class GenericArray;
        -:  643:template <bool, typename> class GenericObject;
        -:  644:
        -:  645:///////////////////////////////////////////////////////////////////////////////
        -:  646:// GenericValue
        -:  647:
        -:  648://! Represents a JSON value. Use Value for UTF8 encoding and default allocator.
        -:  649:/*!
        -:  650:    A JSON value can be one of 7 types. This class is a variant type supporting
        -:  651:    these types.
        -:  652:
        -:  653:    Use the Value if UTF8 and default allocator
        -:  654:
        -:  655:    \tparam Encoding    Encoding of the value. (Even non-string values need to have the same encoding in a document)
        -:  656:    \tparam Allocator   Allocator type for allocating memory of object, array and string.
        -:  657:*/
        -:  658:template <typename Encoding, typename Allocator = RAPIDJSON_DEFAULT_ALLOCATOR >
        -:  659:class GenericValue {
        -:  660:public:
        -:  661:    //! Name-value pair in an object.
        -:  662:    typedef GenericMember<Encoding, Allocator> Member;
        -:  663:    typedef Encoding EncodingType;                  //!< Encoding type from template parameter.
        -:  664:    typedef Allocator AllocatorType;                //!< Allocator type from template parameter.
        -:  665:    typedef typename Encoding::Ch Ch;               //!< Character type derived from Encoding.
        -:  666:    typedef GenericStringRef<Ch> StringRefType;     //!< Reference to a constant string
        -:  667:    typedef typename GenericMemberIterator<false,Encoding,Allocator>::Iterator MemberIterator;  //!< Member iterator for iterating in object.
        -:  668:    typedef typename GenericMemberIterator<true,Encoding,Allocator>::Iterator ConstMemberIterator;  //!< Constant member iterator for iterating in object.
        -:  669:    typedef GenericValue* ValueIterator;            //!< Value iterator for iterating in array.
        -:  670:    typedef const GenericValue* ConstValueIterator; //!< Constant value iterator for iterating in array.
        -:  671:    typedef GenericValue<Encoding, Allocator> ValueType;    //!< Value type of itself.
        -:  672:    typedef GenericArray<false, ValueType> Array;
        -:  673:    typedef GenericArray<true, ValueType> ConstArray;
        -:  674:    typedef GenericObject<false, ValueType> Object;
        -:  675:    typedef GenericObject<true, ValueType> ConstObject;
        -:  676:
        -:  677:    //!@name Constructors and destructor.
        -:  678:    //@{
        -:  679:
        -:  680:    //! Default constructor creates a null value.
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2Ev called 70 returned 100% blocks executed 100%
       70:  681:    GenericValue() RAPIDJSON_NOEXCEPT : data_() { data_.f.flags = kNullFlag; }
        -:  682:
        -:  683:#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -:  684:    //! Move constructor in C++11
        -:  685:    GenericValue(GenericValue&& rhs) RAPIDJSON_NOEXCEPT : data_(rhs.data_) {
        -:  686:        rhs.data_.f.flags = kNullFlag; // give up contents
        -:  687:    }
        -:  688:#endif
        -:  689:
        -:  690:private:
        -:  691:    //! Copy constructor is not permitted.
        -:  692:    GenericValue(const GenericValue& rhs);
        -:  693:
        -:  694:#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -:  695:    //! Moving from a GenericDocument is not permitted.
        -:  696:    template <typename StackAllocator>
        -:  697:    GenericValue(GenericDocument<Encoding,Allocator,StackAllocator>&& rhs);
        -:  698:
        -:  699:    //! Move assignment from a GenericDocument is not permitted.
        -:  700:    template <typename StackAllocator>
        -:  701:    GenericValue& operator=(GenericDocument<Encoding,Allocator,StackAllocator>&& rhs);
        -:  702:#endif
        -:  703:
        -:  704:public:
        -:  705:
        -:  706:    //! Constructor with JSON value type.
        -:  707:    /*! This creates a Value of specified type with default content.
        -:  708:        \param type Type of the value.
        -:  709:        \note Default content for number is zero.
        -:  710:    */
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2ENS_4TypeE called 3167 returned 100% blocks executed 71%
     3167:  711:    explicit GenericValue(Type type) RAPIDJSON_NOEXCEPT : data_() {
        -:  712:        static const uint16_t defaultFlags[] = {
        -:  713:            kNullFlag, kFalseFlag, kTrueFlag, kObjectFlag, kArrayFlag, kShortStringFlag,
        -:  714:            kNumberAnyFlag
        -:  715:        };
    3167*:  716:        RAPIDJSON_NOEXCEPT_ASSERT(type >= kNullType && type <= kNumberType);
     3167:  716-block  0
branch  0 taken 3167 (fallthrough)
branch  1 taken 0
     3167:  716-block  1
branch  2 taken 3167 (fallthrough)
branch  3 taken 0
    %%%%%:  716-block  2
call    4 never executed
     3167:  717:        data_.f.flags = defaultFlags[type];
        -:  718:
        -:  719:        // Use ShortString to store empty string.
     3167:  720:        if (type == kStringType)
     3167:  720-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3167
    #####:  721:            data_.ss.SetLength(0);
    %%%%%:  721-block  0
call    0 never executed
     3167:  722:    }
        -:  723:
        -:  724:    //! Explicit copy constructor (with allocator)
        -:  725:    /*! Creates a copy of a Value by using the given Allocator
        -:  726:        \tparam SourceAllocator allocator of \c rhs
        -:  727:        \param rhs Value to copy from (read-only)
        -:  728:        \param allocator Allocator for allocating copied elements and buffers. Commonly use GenericDocument::GetAllocator().
        -:  729:        \param copyConstStrings Force copying of constant strings (e.g. referencing an in-situ buffer)
        -:  730:        \see CopyFrom()
        -:  731:    */
        -:  732:    template <typename SourceAllocator>
        -:  733:    GenericValue(const GenericValue<Encoding,SourceAllocator>& rhs, Allocator& allocator, bool copyConstStrings = false) {
        -:  734:        switch (rhs.GetType()) {
        -:  735:        case kObjectType:
        -:  736:            DoCopyMembers(rhs, allocator, copyConstStrings);
        -:  737:            break;
        -:  738:        case kArrayType: {
        -:  739:                SizeType count = rhs.data_.a.size;
        -:  740:                GenericValue* le = reinterpret_cast<GenericValue*>(allocator.Malloc(count * sizeof(GenericValue)));
        -:  741:                const GenericValue<Encoding,SourceAllocator>* re = rhs.GetElementsPointer();
        -:  742:                for (SizeType i = 0; i < count; i++)
        -:  743:                    new (&le[i]) GenericValue(re[i], allocator, copyConstStrings);
        -:  744:                data_.f.flags = kArrayFlag;
        -:  745:                data_.a.size = data_.a.capacity = count;
        -:  746:                SetElementsPointer(le);
        -:  747:            }
        -:  748:            break;
        -:  749:        case kStringType:
        -:  750:            if (rhs.data_.f.flags == kConstStringFlag && !copyConstStrings) {
        -:  751:                data_.f.flags = rhs.data_.f.flags;
        -:  752:                data_  = *reinterpret_cast<const Data*>(&rhs.data_);
        -:  753:            }
        -:  754:            else
        -:  755:                SetStringRaw(StringRef(rhs.GetString(), rhs.GetStringLength()), allocator);
        -:  756:            break;
        -:  757:        default:
        -:  758:            data_.f.flags = rhs.data_.f.flags;
        -:  759:            data_  = *reinterpret_cast<const Data*>(&rhs.data_);
        -:  760:            break;
        -:  761:        }
        -:  762:    }
        -:  763:
        -:  764:    //! Constructor for boolean value.
        -:  765:    /*! \param b Boolean value
        -:  766:        \note This constructor is limited to \em real boolean values and rejects
        -:  767:            implicitly converted types like arbitrary pointers.  Use an explicit cast
        -:  768:            to \c bool, if you want to construct a boolean JSON value in such cases.
        -:  769:     */
        -:  770:#ifndef RAPIDJSON_DOXYGEN_RUNNING // hide SFINAE from Doxygen
        -:  771:    template <typename T>
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2IbEET_PNS_8internal8EnableIfINS9_15RemoveSfinaeTagIPFRNS9_9SfinaeTagENS9_6IsSameIbS8_EEEE4TypeEvE4TypeE called 0 returned 0% blocks executed 0%
    #####:  772:    explicit GenericValue(T b, RAPIDJSON_ENABLEIF((internal::IsSame<bool, T>))) RAPIDJSON_NOEXCEPT  // See #472
        -:  773:#else
        -:  774:    explicit GenericValue(bool b) RAPIDJSON_NOEXCEPT
        -:  775:#endif
    #####:  776:        : data_() {
        -:  777:            // safe-guard against failing SFINAE
        -:  778:            RAPIDJSON_STATIC_ASSERT((internal::IsSame<bool,T>::Value));
    #####:  779:            data_.f.flags = b ? kTrueFlag : kFalseFlag;
    %%%%%:  779-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  779-block  1
    %%%%%:  779-block  2
    #####:  780:    }
        -:  781:
        -:  782:    //! Constructor for int value.
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2Ei called 0 returned 0% blocks executed 0%
    #####:  783:    explicit GenericValue(int i) RAPIDJSON_NOEXCEPT : data_() {
    #####:  784:        data_.n.i64 = i;
    #####:  785:        data_.f.flags = (i >= 0) ? (kNumberIntFlag | kUintFlag | kUint64Flag) : kNumberIntFlag;
    %%%%%:  785-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  785-block  1
    %%%%%:  785-block  2
    #####:  786:    }
        -:  787:
        -:  788:    //! Constructor for unsigned value.
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2Ej called 847 returned 100% blocks executed 75%
      847:  789:    explicit GenericValue(unsigned u) RAPIDJSON_NOEXCEPT : data_() {
      847:  790:        data_.n.u64 = u; 
     847*:  791:        data_.f.flags = (u & 0x80000000) ? kNumberUintFlag : (kNumberUintFlag | kIntFlag | kInt64Flag);
      847:  791-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 847
    %%%%%:  791-block  1
      847:  791-block  2
      847:  792:    }
        -:  793:
        -:  794:    //! Constructor for int64_t value.
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2El called 0 returned 0% blocks executed 0%
    #####:  795:    explicit GenericValue(int64_t i64) RAPIDJSON_NOEXCEPT : data_() {
    #####:  796:        data_.n.i64 = i64;
    #####:  797:        data_.f.flags = kNumberInt64Flag;
    #####:  798:        if (i64 >= 0) {
    %%%%%:  798-block  0
branch  0 never executed
branch  1 never executed
    #####:  799:            data_.f.flags |= kNumberUint64Flag;
    #####:  800:            if (!(static_cast<uint64_t>(i64) & RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x00000000)))
    %%%%%:  800-block  0
branch  0 never executed
branch  1 never executed
    #####:  801:                data_.f.flags |= kUintFlag;
    %%%%%:  801-block  0
    #####:  802:            if (!(static_cast<uint64_t>(i64) & RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
    %%%%%:  802-block  0
branch  0 never executed
branch  1 never executed
    #####:  803:                data_.f.flags |= kIntFlag;
    %%%%%:  803-block  0
        -:  804:        }
    #####:  805:        else if (i64 >= static_cast<int64_t>(RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
    %%%%%:  805-block  0
branch  0 never executed
branch  1 never executed
    #####:  806:            data_.f.flags |= kIntFlag;
    %%%%%:  806-block  0
    #####:  807:    }
        -:  808:
        -:  809:    //! Constructor for uint64_t value.
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2Em called 0 returned 0% blocks executed 0%
    #####:  810:    explicit GenericValue(uint64_t u64) RAPIDJSON_NOEXCEPT : data_() {
    #####:  811:        data_.n.u64 = u64;
    #####:  812:        data_.f.flags = kNumberUint64Flag;
    #####:  813:        if (!(u64 & RAPIDJSON_UINT64_C2(0x80000000, 0x00000000)))
    %%%%%:  813-block  0
branch  0 never executed
branch  1 never executed
    #####:  814:            data_.f.flags |= kInt64Flag;
    %%%%%:  814-block  0
    #####:  815:        if (!(u64 & RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x00000000)))
    %%%%%:  815-block  0
branch  0 never executed
branch  1 never executed
    #####:  816:            data_.f.flags |= kUintFlag;
    %%%%%:  816-block  0
    #####:  817:        if (!(u64 & RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
    %%%%%:  817-block  0
branch  0 never executed
branch  1 never executed
    #####:  818:            data_.f.flags |= kIntFlag;
    %%%%%:  818-block  0
    #####:  819:    }
        -:  820:
        -:  821:    //! Constructor for double value.
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2Ed called 0 returned 0% blocks executed 0%
    #####:  822:    explicit GenericValue(double d) RAPIDJSON_NOEXCEPT : data_() { data_.n.d = d; data_.f.flags = kNumberDoubleFlag; }
        -:  823:
        -:  824:    //! Constructor for float value.
        -:  825:    explicit GenericValue(float f) RAPIDJSON_NOEXCEPT : data_() { data_.n.d = static_cast<double>(f); data_.f.flags = kNumberDoubleFlag; }
        -:  826:
        -:  827:    //! Constructor for constant string (i.e. do not make a copy of string)
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2EPKcj called 0 returned 0% blocks executed 0%
    #####:  828:    GenericValue(const Ch* s, SizeType length) RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(StringRef(s, length)); }
    %%%%%:  828-block  0
call    0 never executed
call    1 never executed
        -:  829:
        -:  830:    //! Constructor for constant string (i.e. do not make a copy of string)
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2ENS_16GenericStringRefIcEE called 249 returned 100% blocks executed 100%
      249:  831:    explicit GenericValue(StringRefType s) RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(s); }
      249:  831-block  0
call    0 returned 249
call    1 returned 249
        -:  832:
        -:  833:    //! Constructor for copy-string (i.e. do make a copy of string)
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEC2EPKcjRS5_ called 12824 returned 100% blocks executed 100%
    12824:  834:    GenericValue(const Ch* s, SizeType length, Allocator& allocator) : data_() { SetStringRaw(StringRef(s, length), allocator); }
    12824:  834-block  0
call    0 returned 12824
call    1 returned 12824
branch  2 taken 12824 (fallthrough)
branch  3 taken 0 (throw)
    12824:  834-block  1
        -:  835:
        -:  836:    //! Constructor for copy-string (i.e. do make a copy of string)
        -:  837:    GenericValue(const Ch*s, Allocator& allocator) : data_() { SetStringRaw(StringRef(s), allocator); }
        -:  838:
        -:  839:#if RAPIDJSON_HAS_STDSTRING
        -:  840:    //! Constructor for copy-string from a string object (i.e. do make a copy of string)
        -:  841:    /*! \note Requires the definition of the preprocessor symbol \ref RAPIDJSON_HAS_STDSTRING.
        -:  842:     */
        -:  843:    GenericValue(const std::basic_string<Ch>& s, Allocator& allocator) : data_() { SetStringRaw(StringRef(s), allocator); }
        -:  844:#endif
        -:  845:
        -:  846:    //! Constructor for Array.
        -:  847:    /*!
        -:  848:        \param a An array obtained by \c GetArray().
        -:  849:        \note \c Array is always pass-by-value.
        -:  850:        \note the source array is moved into this value and the sourec array becomes empty.
        -:  851:    */
        -:  852:    GenericValue(Array a) RAPIDJSON_NOEXCEPT : data_(a.value_.data_) {
        -:  853:        a.value_.data_ = Data();
        -:  854:        a.value_.data_.f.flags = kArrayFlag;
        -:  855:    }
        -:  856:
        -:  857:    //! Constructor for Object.
        -:  858:    /*!
        -:  859:        \param o An object obtained by \c GetObject().
        -:  860:        \note \c Object is always pass-by-value.
        -:  861:        \note the source object is moved into this value and the sourec object becomes empty.
        -:  862:    */
        -:  863:    GenericValue(Object o) RAPIDJSON_NOEXCEPT : data_(o.value_.data_) {
        -:  864:        o.value_.data_ = Data();
        -:  865:        o.value_.data_.f.flags = kObjectFlag;
        -:  866:    }
        -:  867:
        -:  868:    //! Destructor.
        -:  869:    /*! Need to destruct elements of array, members of object, or copy-string.
        -:  870:    */
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEED2Ev called 269 returned 100% blocks executed 100%
      269:  871:    ~GenericValue() {
      269:  871-block  0
        -:  872:        // With RAPIDJSON_USE_MEMBERSMAP, the maps need to be destroyed to release
        -:  873:        // their Allocator if it's refcounted (e.g. MemoryPoolAllocator).
        -:  874:        if (Allocator::kNeedFree || (RAPIDJSON_USE_MEMBERSMAP+0 &&
        -:  875:                                     internal::IsRefCounted<Allocator>::Value)) {
        -:  876:            switch(data_.f.flags) {
        -:  877:            case kArrayFlag:
        -:  878:                {
        -:  879:                    GenericValue* e = GetElementsPointer();
        -:  880:                    for (GenericValue* v = e; v != e + data_.a.size; ++v)
        -:  881:                        v->~GenericValue();
        -:  882:                    if (Allocator::kNeedFree) { // Shortcut by Allocator's trait
        -:  883:                        Allocator::Free(e);
        -:  884:                    }
        -:  885:                }
        -:  886:                break;
        -:  887:
        -:  888:            case kObjectFlag:
        -:  889:                DoFreeMembers();
        -:  890:                break;
        -:  891:
        -:  892:            case kCopyStringFlag:
        -:  893:                if (Allocator::kNeedFree) { // Shortcut by Allocator's trait
        -:  894:                    Allocator::Free(const_cast<Ch*>(GetStringPointer()));
        -:  895:                }
        -:  896:                break;
        -:  897:
        -:  898:            default:
        -:  899:                break;  // Do nothing for other types.
        -:  900:            }
        -:  901:        }
      269:  902:    }
        -:  903:
        -:  904:    //@}
        -:  905:
        -:  906:    //!@name Assignment operators
        -:  907:    //@{
        -:  908:
        -:  909:    //! Assignment with move semantics.
        -:  910:    /*! \param rhs Source of the assignment. It will become a null value after assignment.
        -:  911:    */
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEaSERS6_ called 5 returned 100% blocks executed 100%
        5:  912:    GenericValue& operator=(GenericValue& rhs) RAPIDJSON_NOEXCEPT {
        5:  913:        if (RAPIDJSON_LIKELY(this != &rhs)) {
        5:  913-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        -:  914:            // Can't destroy "this" before assigning "rhs", otherwise "rhs"
        -:  915:            // could be used after free if it's an sub-Value of "this",
        -:  916:            // hence the temporary danse.
       10:  917:            GenericValue temp;
        5:  917-block  0
call    0 returned 5
call    1 returned 5
        5:  918:            temp.RawAssign(rhs);
call    0 returned 5
        5:  919:            this->~GenericValue();
call    0 returned 5
        5:  920:            RawAssign(temp);
call    0 returned 5
        -:  921:        }
        5:  922:        return *this;
        5:  922-block  0
        -:  923:    }
        -:  924:
        -:  925:#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -:  926:    //! Move assignment in C++11
        -:  927:    GenericValue& operator=(GenericValue&& rhs) RAPIDJSON_NOEXCEPT {
        -:  928:        return *this = rhs.Move();
        -:  929:    }
        -:  930:#endif
        -:  931:
        -:  932:    //! Assignment of constant string reference (no copy)
        -:  933:    /*! \param str Constant string reference to be assigned
        -:  934:        \note This overload is needed to avoid clashes with the generic primitive type assignment overload below.
        -:  935:        \see GenericStringRef, operator=(T)
        -:  936:    */
        -:  937:    GenericValue& operator=(StringRefType str) RAPIDJSON_NOEXCEPT {
        -:  938:        GenericValue s(str);
        -:  939:        return *this = s;
        -:  940:    }
        -:  941:
        -:  942:    //! Assignment with primitive types.
        -:  943:    /*! \tparam T Either \ref Type, \c int, \c unsigned, \c int64_t, \c uint64_t
        -:  944:        \param value The value to be assigned.
        -:  945:
        -:  946:        \note The source type \c T explicitly disallows all pointer types,
        -:  947:            especially (\c const) \ref Ch*.  This helps avoiding implicitly
        -:  948:            referencing character strings with insufficient lifetime, use
        -:  949:            \ref SetString(const Ch*, Allocator&) (for copying) or
        -:  950:            \ref StringRef() (to explicitly mark the pointer as constant) instead.
        -:  951:            All other pointer types would implicitly convert to \c bool,
        -:  952:            use \ref SetBool() instead.
        -:  953:    */
        -:  954:    template <typename T>
        -:  955:    RAPIDJSON_DISABLEIF_RETURN((internal::IsPointer<T>), (GenericValue&))
        -:  956:    operator=(T value) {
        -:  957:        GenericValue v(value);
        -:  958:        return *this = v;
        -:  959:    }
        -:  960:
        -:  961:    //! Deep-copy assignment from Value
        -:  962:    /*! Assigns a \b copy of the Value to the current Value object
        -:  963:        \tparam SourceAllocator Allocator type of \c rhs
        -:  964:        \param rhs Value to copy from (read-only)
        -:  965:        \param allocator Allocator to use for copying
        -:  966:        \param copyConstStrings Force copying of constant strings (e.g. referencing an in-situ buffer)
        -:  967:     */
        -:  968:    template <typename SourceAllocator>
        -:  969:    GenericValue& CopyFrom(const GenericValue<Encoding, SourceAllocator>& rhs, Allocator& allocator, bool copyConstStrings = false) {
        -:  970:        RAPIDJSON_ASSERT(static_cast<void*>(this) != static_cast<void const*>(&rhs));
        -:  971:        this->~GenericValue();
        -:  972:        new (this) GenericValue(rhs, allocator, copyConstStrings);
        -:  973:        return *this;
        -:  974:    }
        -:  975:
        -:  976:    //! Exchange the contents of this value with those of other.
        -:  977:    /*!
        -:  978:        \param other Another value.
        -:  979:        \note Constant complexity.
        -:  980:    */
        -:  981:    GenericValue& Swap(GenericValue& other) RAPIDJSON_NOEXCEPT {
        -:  982:        GenericValue temp;
        -:  983:        temp.RawAssign(*this);
        -:  984:        RawAssign(other);
        -:  985:        other.RawAssign(temp);
        -:  986:        return *this;
        -:  987:    }
        -:  988:
        -:  989:    //! free-standing swap function helper
        -:  990:    /*!
        -:  991:        Helper function to enable support for common swap implementation pattern based on \c std::swap:
        -:  992:        \code
        -:  993:        void swap(MyClass& a, MyClass& b) {
        -:  994:            using std::swap;
        -:  995:            swap(a.value, b.value);
        -:  996:            // ...
        -:  997:        }
        -:  998:        \endcode
        -:  999:        \see Swap()
        -: 1000:     */
        -: 1001:    friend inline void swap(GenericValue& a, GenericValue& b) RAPIDJSON_NOEXCEPT { a.Swap(b); }
        -: 1002:
        -: 1003:    //! Prepare Value for move semantics
        -: 1004:    /*! \return *this */
        -: 1005:    GenericValue& Move() RAPIDJSON_NOEXCEPT { return *this; }
        -: 1006:    //@}
        -: 1007:
        -: 1008:    //!@name Equal-to and not-equal-to operators
        -: 1009:    //@{
        -: 1010:    //! Equal-to operator
        -: 1011:    /*!
        -: 1012:        \note If an object contains duplicated named member, comparing equality with any object is always \c false.
        -: 1013:        \note Complexity is quadratic in Object's member number and linear for the rest (number of all values in the subtree and total lengths of all strings).
        -: 1014:    */
        -: 1015:    template <typename SourceAllocator>
        -: 1016:    bool operator==(const GenericValue<Encoding, SourceAllocator>& rhs) const {
        -: 1017:        typedef GenericValue<Encoding, SourceAllocator> RhsType;
        -: 1018:        if (GetType() != rhs.GetType())
        -: 1019:            return false;
        -: 1020:
        -: 1021:        switch (GetType()) {
        -: 1022:        case kObjectType: // Warning: O(n^2) inner-loop
        -: 1023:            if (data_.o.size != rhs.data_.o.size)
        -: 1024:                return false;           
        -: 1025:            for (ConstMemberIterator lhsMemberItr = MemberBegin(); lhsMemberItr != MemberEnd(); ++lhsMemberItr) {
        -: 1026:                typename RhsType::ConstMemberIterator rhsMemberItr = rhs.FindMember(lhsMemberItr->name);
        -: 1027:                if (rhsMemberItr == rhs.MemberEnd() || lhsMemberItr->value != rhsMemberItr->value)
        -: 1028:                    return false;
        -: 1029:            }
        -: 1030:            return true;
        -: 1031:            
        -: 1032:        case kArrayType:
        -: 1033:            if (data_.a.size != rhs.data_.a.size)
        -: 1034:                return false;
        -: 1035:            for (SizeType i = 0; i < data_.a.size; i++)
        -: 1036:                if ((*this)[i] != rhs[i])
        -: 1037:                    return false;
        -: 1038:            return true;
        -: 1039:
        -: 1040:        case kStringType:
        -: 1041:            return StringEqual(rhs);
        -: 1042:
        -: 1043:        case kNumberType:
        -: 1044:            if (IsDouble() || rhs.IsDouble()) {
        -: 1045:                double a = GetDouble();     // May convert from integer to double.
        -: 1046:                double b = rhs.GetDouble(); // Ditto
        -: 1047:                return a >= b && a <= b;    // Prevent -Wfloat-equal
        -: 1048:            }
        -: 1049:            else
        -: 1050:                return data_.n.u64 == rhs.data_.n.u64;
        -: 1051:
        -: 1052:        default:
        -: 1053:            return true;
        -: 1054:        }
        -: 1055:    }
        -: 1056:
        -: 1057:    //! Equal-to operator with const C-string pointer
        -: 1058:    bool operator==(const Ch* rhs) const { return *this == GenericValue(StringRef(rhs)); }
        -: 1059:
        -: 1060:#if RAPIDJSON_HAS_STDSTRING
        -: 1061:    //! Equal-to operator with string object
        -: 1062:    /*! \note Requires the definition of the preprocessor symbol \ref RAPIDJSON_HAS_STDSTRING.
        -: 1063:     */
        -: 1064:    bool operator==(const std::basic_string<Ch>& rhs) const { return *this == GenericValue(StringRef(rhs)); }
        -: 1065:#endif
        -: 1066:
        -: 1067:    //! Equal-to operator with primitive types
        -: 1068:    /*! \tparam T Either \ref Type, \c int, \c unsigned, \c int64_t, \c uint64_t, \c double, \c true, \c false
        -: 1069:    */
        -: 1070:    template <typename T> RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>,internal::IsGenericValue<T> >), (bool)) operator==(const T& rhs) const { return *this == GenericValue(rhs); }
        -: 1071:
        -: 1072:    //! Not-equal-to operator
        -: 1073:    /*! \return !(*this == rhs)
        -: 1074:     */
        -: 1075:    template <typename SourceAllocator>
        -: 1076:    bool operator!=(const GenericValue<Encoding, SourceAllocator>& rhs) const { return !(*this == rhs); }
        -: 1077:
        -: 1078:    //! Not-equal-to operator with const C-string pointer
        -: 1079:    bool operator!=(const Ch* rhs) const { return !(*this == rhs); }
        -: 1080:
        -: 1081:    //! Not-equal-to operator with arbitrary types
        -: 1082:    /*! \return !(*this == rhs)
        -: 1083:     */
        -: 1084:    template <typename T> RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator!=(const T& rhs) const { return !(*this == rhs); }
        -: 1085:
        -: 1086:#ifndef __cpp_lib_three_way_comparison
        -: 1087:    //! Equal-to operator with arbitrary types (symmetric version)
        -: 1088:    /*! \return (rhs == lhs)
        -: 1089:     */
        -: 1090:    template <typename T> friend RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator==(const T& lhs, const GenericValue& rhs) { return rhs == lhs; }
        -: 1091:
        -: 1092:    //! Not-Equal-to operator with arbitrary types (symmetric version)
        -: 1093:    /*! \return !(rhs == lhs)
        -: 1094:     */
        -: 1095:    template <typename T> friend RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator!=(const T& lhs, const GenericValue& rhs) { return !(rhs == lhs); }
        -: 1096:    //@}
        -: 1097:#endif
        -: 1098:
        -: 1099:    //!@name Type
        -: 1100:    //@{
        -: 1101:
        -: 1102:    Type GetType()  const { return static_cast<Type>(data_.f.flags & kTypeMask); }
        -: 1103:    bool IsNull()   const { return data_.f.flags == kNullFlag; }
        -: 1104:    bool IsFalse()  const { return data_.f.flags == kFalseFlag; }
        -: 1105:    bool IsTrue()   const { return data_.f.flags == kTrueFlag; }
        -: 1106:    bool IsBool()   const { return (data_.f.flags & kBoolFlag) != 0; }
function _ZNK9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE8IsObjectEv called 1216 returned 100% blocks executed 100%
     1216: 1107:    bool IsObject() const { return data_.f.flags == kObjectFlag; }
     1216: 1107-block  0
function _ZNK9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE7IsArrayEv called 55 returned 100% blocks executed 100%
       55: 1108:    bool IsArray()  const { return data_.f.flags == kArrayFlag; }
       55: 1108-block  0
        -: 1109:    bool IsNumber() const { return (data_.f.flags & kNumberFlag) != 0; }
        -: 1110:    bool IsInt()    const { return (data_.f.flags & kIntFlag) != 0; }
        -: 1111:    bool IsUint()   const { return (data_.f.flags & kUintFlag) != 0; }
        -: 1112:    bool IsInt64()  const { return (data_.f.flags & kInt64Flag) != 0; }
        -: 1113:    bool IsUint64() const { return (data_.f.flags & kUint64Flag) != 0; }
        -: 1114:    bool IsDouble() const { return (data_.f.flags & kDoubleFlag) != 0; }
function _ZNK9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE8IsStringEv called 2822 returned 100% blocks executed 100%
     2822: 1115:    bool IsString() const { return (data_.f.flags & kStringFlag) != 0; }
     2822: 1115-block  0
        -: 1116:
        -: 1117:    // Checks whether a number can be losslessly converted to a double.
        -: 1118:    bool IsLosslessDouble() const {
        -: 1119:        if (!IsNumber()) return false;
        -: 1120:        if (IsUint64()) {
        -: 1121:            uint64_t u = GetUint64();
        -: 1122:            volatile double d = static_cast<double>(u);
        -: 1123:            return (d >= 0.0)
        -: 1124:                && (d < static_cast<double>((std::numeric_limits<uint64_t>::max)()))
        -: 1125:                && (u == static_cast<uint64_t>(d));
        -: 1126:        }
        -: 1127:        if (IsInt64()) {
        -: 1128:            int64_t i = GetInt64();
        -: 1129:            volatile double d = static_cast<double>(i);
        -: 1130:            return (d >= static_cast<double>((std::numeric_limits<int64_t>::min)()))
        -: 1131:                && (d < static_cast<double>((std::numeric_limits<int64_t>::max)()))
        -: 1132:                && (i == static_cast<int64_t>(d));
        -: 1133:        }
        -: 1134:        return true; // double, int, uint are always lossless
        -: 1135:    }
        -: 1136:
        -: 1137:    // Checks whether a number is a float (possible lossy).
        -: 1138:    bool IsFloat() const  {
        -: 1139:        if ((data_.f.flags & kDoubleFlag) == 0)
        -: 1140:            return false;
        -: 1141:        double d = GetDouble();
        -: 1142:        return d >= -3.4028234e38 && d <= 3.4028234e38;
        -: 1143:    }
        -: 1144:    // Checks whether a number can be losslessly converted to a float.
        -: 1145:    bool IsLosslessFloat() const {
        -: 1146:        if (!IsNumber()) return false;
        -: 1147:        double a = GetDouble();
        -: 1148:        if (a < static_cast<double>(-(std::numeric_limits<float>::max)())
        -: 1149:                || a > static_cast<double>((std::numeric_limits<float>::max)()))
        -: 1150:            return false;
        -: 1151:        double b = static_cast<double>(static_cast<float>(a));
        -: 1152:        return a >= b && a <= b;    // Prevent -Wfloat-equal
        -: 1153:    }
        -: 1154:
        -: 1155:    //@}
        -: 1156:
        -: 1157:    //!@name Null
        -: 1158:    //@{
        -: 1159:
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE7SetNullEv called 5 returned 100% blocks executed 100%
       10: 1160:    GenericValue& SetNull() { this->~GenericValue(); new (this) GenericValue(); return *this; }
        5: 1160-block  0
call    0 returned 5
call    1 returned 5
        -: 1161:
        -: 1162:    //@}
        -: 1163:
        -: 1164:    //!@name Bool
        -: 1165:    //@{
        -: 1166:
        -: 1167:    bool GetBool() const { RAPIDJSON_ASSERT(IsBool()); return data_.f.flags == kTrueFlag; }
        -: 1168:    //!< Set boolean value
        -: 1169:    /*! \post IsBool() == true */
        -: 1170:    GenericValue& SetBool(bool b) { this->~GenericValue(); new (this) GenericValue(b); return *this; }
        -: 1171:
        -: 1172:    //@}
        -: 1173:
        -: 1174:    //!@name Object
        -: 1175:    //@{
        -: 1176:
        -: 1177:    //! Set this value as an empty object.
        -: 1178:    /*! \post IsObject() == true */
        -: 1179:    GenericValue& SetObject() { this->~GenericValue(); new (this) GenericValue(kObjectType); return *this; }
        -: 1180:
        -: 1181:    //! Get the number of members in the object.
        -: 1182:    SizeType MemberCount() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.size; }
        -: 1183:
        -: 1184:    //! Get the capacity of object.
        -: 1185:    SizeType MemberCapacity() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.capacity; }
        -: 1186:
        -: 1187:    //! Check whether the object is empty.
        -: 1188:    bool ObjectEmpty() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.size == 0; }
        -: 1189:
        -: 1190:    //! Get a value from an object associated with the name.
        -: 1191:    /*! \pre IsObject() == true
        -: 1192:        \tparam T Either \c Ch or \c const \c Ch (template used for disambiguation with \ref operator[](SizeType))
        -: 1193:        \note In version 0.1x, if the member is not found, this function returns a null value. This makes issue 7.
        -: 1194:        Since 0.2, if the name is not correct, it will assert.
        -: 1195:        If user is unsure whether a member exists, user should use HasMember() first.
        -: 1196:        A better approach is to use FindMember().
        -: 1197:        \note Linear time complexity.
        -: 1198:    */
        -: 1199:    template <typename T>
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEixIKcEENS_8internal9DisableIfINS9_15RemoveSfinaeTagIPFRNS9_9SfinaeTagENS9_7NotExprINS9_6IsSameINS9_11RemoveConstIT_E4TypeEcEEEEEE4TypeERS6_E4TypeEPSH_ called 249 returned 100% blocks executed 80%
      249: 1200:    RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >),(GenericValue&)) operator[](T* name) {
      498: 1201:        GenericValue n(StringRef(name));
      249: 1201-block  0
call    0 returned 249
branch  1 taken 249 (fallthrough)
branch  2 taken 0 (throw)
      249: 1201-block  1
call    3 returned 249
      249: 1201-block  2
call    4 returned 249
    $$$$$: 1201-block  3
call    5 never executed
      498: 1202:        return (*this)[n];
call    0 returned 249
branch  1 taken 249 (fallthrough)
branch  2 taken 0 (throw)
      249: 1202-block  0
      249: 1202-block  1
        -: 1203:    }
        -: 1204:    template <typename T>
        -: 1205:    RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >),(const GenericValue&)) operator[](T* name) const { return const_cast<GenericValue&>(*this)[name]; }
        -: 1206:
        -: 1207:    //! Get a value from an object associated with the name.
        -: 1208:    /*! \pre IsObject() == true
        -: 1209:        \tparam SourceAllocator Allocator of the \c name value
        -: 1210:
        -: 1211:        \note Compared to \ref operator[](T*), this version is faster because it does not need a StrLen().
        -: 1212:        And it can also handle strings with embedded null characters.
        -: 1213:
        -: 1214:        \note Linear time complexity.
        -: 1215:    */
        -: 1216:    template <typename SourceAllocator>
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEixIS5_EERS6_RKNS0_IS2_T_EE called 249 returned 100% blocks executed 89%
      249: 1217:    GenericValue& operator[](const GenericValue<Encoding, SourceAllocator>& name) {
      249: 1218:        MemberIterator member = FindMember(name);
      249: 1218-block  0
call    0 returned 249
branch  1 taken 249 (fallthrough)
branch  2 taken 0 (throw)
      249: 1219:        if (member != MemberEnd())
      249: 1219-block  0
call    0 returned 249
branch  1 taken 249 (fallthrough)
branch  2 taken 0 (throw)
      249: 1219-block  1
call    3 returned 249
branch  4 taken 249 (fallthrough)
branch  5 taken 0
      249: 1220:            return member->value;
      249: 1220-block  0
call    0 returned 249
        -: 1221:        else {
    #####: 1222:            RAPIDJSON_ASSERT(false);    // see above note
    %%%%%: 1222-block  0
call    0 never executed
        -: 1223:
        -: 1224:            // This will generate -Wexit-time-destructors in clang
        -: 1225:            // static GenericValue NullValue;
        -: 1226:            // return NullValue;
        -: 1227:
        -: 1228:            // Use static buffer and placement-new to prevent destruction
        -: 1229:            static char buffer[sizeof(GenericValue)];
        -: 1230:            return *new (buffer) GenericValue();
        -: 1231:        }
        -: 1232:    }
        -: 1233:    template <typename SourceAllocator>
        -: 1234:    const GenericValue& operator[](const GenericValue<Encoding, SourceAllocator>& name) const { return const_cast<GenericValue&>(*this)[name]; }
        -: 1235:
        -: 1236:#if RAPIDJSON_HAS_STDSTRING
        -: 1237:    //! Get a value from an object associated with name (string object).
        -: 1238:    GenericValue& operator[](const std::basic_string<Ch>& name) { return (*this)[GenericValue(StringRef(name))]; }
        -: 1239:    const GenericValue& operator[](const std::basic_string<Ch>& name) const { return (*this)[GenericValue(StringRef(name))]; }
        -: 1240:#endif
        -: 1241:
        -: 1242:    //! Const member iterator
        -: 1243:    /*! \pre IsObject() == true */
        -: 1244:    ConstMemberIterator MemberBegin() const { RAPIDJSON_ASSERT(IsObject()); return ConstMemberIterator(GetMembersPointer()); }
        -: 1245:    //! Const \em past-the-end member iterator
        -: 1246:    /*! \pre IsObject() == true */
        -: 1247:    ConstMemberIterator MemberEnd() const   { RAPIDJSON_ASSERT(IsObject()); return ConstMemberIterator(GetMembersPointer() + data_.o.size); }
        -: 1248:    //! Member iterator
        -: 1249:    /*! \pre IsObject() == true */
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE11MemberBeginEv called 249 returned 100% blocks executed 83%
     249*: 1250:    MemberIterator MemberBegin()            { RAPIDJSON_ASSERT(IsObject()); return MemberIterator(GetMembersPointer()); }
      249: 1250-block  0
call    0 returned 249
branch  1 taken 0 (fallthrough)
branch  2 taken 249
    %%%%%: 1250-block  1
call    3 never executed
      249: 1250-block  2
call    4 returned 249
call    5 returned 249
        -: 1251:    //! \em Past-the-end member iterator
        -: 1252:    /*! \pre IsObject() == true */
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE9MemberEndEv called 698 returned 100% blocks executed 83%
     698*: 1253:    MemberIterator MemberEnd()              { RAPIDJSON_ASSERT(IsObject()); return MemberIterator(GetMembersPointer() + data_.o.size); }
      698: 1253-block  0
call    0 returned 698
branch  1 taken 0 (fallthrough)
branch  2 taken 698
    %%%%%: 1253-block  1
call    3 never executed
      698: 1253-block  2
call    4 returned 698
call    5 returned 698
        -: 1254:
        -: 1255:    //! Request the object to have enough capacity to store members.
        -: 1256:    /*! \param newCapacity  The capacity that the object at least need to have.
        -: 1257:        \param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator().
        -: 1258:        \return The value itself for fluent API.
        -: 1259:        \note Linear time complexity.
        -: 1260:    */
        -: 1261:    GenericValue& MemberReserve(SizeType newCapacity, Allocator &allocator) {
        -: 1262:        RAPIDJSON_ASSERT(IsObject());
        -: 1263:        DoReserveMembers(newCapacity, allocator);
        -: 1264:        return *this;
        -: 1265:    }
        -: 1266:
        -: 1267:    //! Check whether a member exists in the object.
        -: 1268:    /*!
        -: 1269:        \param name Member name to be searched.
        -: 1270:        \pre IsObject() == true
        -: 1271:        \return Whether a member with that name exists.
        -: 1272:        \note It is better to use FindMember() directly if you need the obtain the value as well.
        -: 1273:        \note Linear time complexity.
        -: 1274:    */
        -: 1275:    bool HasMember(const Ch* name) const { return FindMember(name) != MemberEnd(); }
        -: 1276:
        -: 1277:#if RAPIDJSON_HAS_STDSTRING
        -: 1278:    //! Check whether a member exists in the object with string object.
        -: 1279:    /*!
        -: 1280:        \param name Member name to be searched.
        -: 1281:        \pre IsObject() == true
        -: 1282:        \return Whether a member with that name exists.
        -: 1283:        \note It is better to use FindMember() directly if you need the obtain the value as well.
        -: 1284:        \note Linear time complexity.
        -: 1285:    */
        -: 1286:    bool HasMember(const std::basic_string<Ch>& name) const { return FindMember(name) != MemberEnd(); }
        -: 1287:#endif
        -: 1288:
        -: 1289:    //! Check whether a member exists in the object with GenericValue name.
        -: 1290:    /*!
        -: 1291:        This version is faster because it does not need a StrLen(). It can also handle string with null character.
        -: 1292:        \param name Member name to be searched.
        -: 1293:        \pre IsObject() == true
        -: 1294:        \return Whether a member with that name exists.
        -: 1295:        \note It is better to use FindMember() directly if you need the obtain the value as well.
        -: 1296:        \note Linear time complexity.
        -: 1297:    */
        -: 1298:    template <typename SourceAllocator>
        -: 1299:    bool HasMember(const GenericValue<Encoding, SourceAllocator>& name) const { return FindMember(name) != MemberEnd(); }
        -: 1300:
        -: 1301:    //! Find member by name.
        -: 1302:    /*!
        -: 1303:        \param name Member name to be searched.
        -: 1304:        \pre IsObject() == true
        -: 1305:        \return Iterator to member, if it exists.
        -: 1306:            Otherwise returns \ref MemberEnd().
        -: 1307:
        -: 1308:        \note Earlier versions of Rapidjson returned a \c NULL pointer, in case
        -: 1309:            the requested member doesn't exist. For consistency with e.g.
        -: 1310:            \c std::map, this has been changed to MemberEnd() now.
        -: 1311:        \note Linear time complexity.
        -: 1312:    */
        -: 1313:    MemberIterator FindMember(const Ch* name) {
        -: 1314:        GenericValue n(StringRef(name));
        -: 1315:        return FindMember(n);
        -: 1316:    }
        -: 1317:
        -: 1318:    ConstMemberIterator FindMember(const Ch* name) const { return const_cast<GenericValue&>(*this).FindMember(name); }
        -: 1319:
        -: 1320:    //! Find member by name.
        -: 1321:    /*!
        -: 1322:        This version is faster because it does not need a StrLen(). It can also handle string with null character.
        -: 1323:        \param name Member name to be searched.
        -: 1324:        \pre IsObject() == true
        -: 1325:        \return Iterator to member, if it exists.
        -: 1326:            Otherwise returns \ref MemberEnd().
        -: 1327:
        -: 1328:        \note Earlier versions of Rapidjson returned a \c NULL pointer, in case
        -: 1329:            the requested member doesn't exist. For consistency with e.g.
        -: 1330:            \c std::map, this has been changed to MemberEnd() now.
        -: 1331:        \note Linear time complexity.
        -: 1332:    */
        -: 1333:    template <typename SourceAllocator>
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE10FindMemberIS5_EENS_21GenericMemberIteratorILb0ES2_S5_EERKNS0_IS2_T_EE called 249 returned 100% blocks executed 75%
      249: 1334:    MemberIterator FindMember(const GenericValue<Encoding, SourceAllocator>& name) {
     249*: 1335:        RAPIDJSON_ASSERT(IsObject());
      249: 1335-block  0
call    0 returned 249
branch  1 taken 0 (fallthrough)
branch  2 taken 249
    %%%%%: 1335-block  1
call    3 never executed
     249*: 1336:        RAPIDJSON_ASSERT(name.IsString());
      249: 1336-block  0
call    0 returned 249
branch  1 taken 0 (fallthrough)
branch  2 taken 249
    %%%%%: 1336-block  1
call    3 never executed
      249: 1337:        return DoFindMember(name);
      249: 1337-block  0
call    0 returned 249
        -: 1338:    }
        -: 1339:    template <typename SourceAllocator> ConstMemberIterator FindMember(const GenericValue<Encoding, SourceAllocator>& name) const { return const_cast<GenericValue&>(*this).FindMember(name); }
        -: 1340:
        -: 1341:#if RAPIDJSON_HAS_STDSTRING
        -: 1342:    //! Find member by string object name.
        -: 1343:    /*!
        -: 1344:        \param name Member name to be searched.
        -: 1345:        \pre IsObject() == true
        -: 1346:        \return Iterator to member, if it exists.
        -: 1347:            Otherwise returns \ref MemberEnd().
        -: 1348:    */
        -: 1349:    MemberIterator FindMember(const std::basic_string<Ch>& name) { return FindMember(GenericValue(StringRef(name))); }
        -: 1350:    ConstMemberIterator FindMember(const std::basic_string<Ch>& name) const { return FindMember(GenericValue(StringRef(name))); }
        -: 1351:#endif
        -: 1352:
        -: 1353:    //! Add a member (name-value pair) to the object.
        -: 1354:    /*! \param name A string value as name of member.
        -: 1355:        \param value Value of any type.
        -: 1356:        \param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator().
        -: 1357:        \return The value itself for fluent API.
        -: 1358:        \note The ownership of \c name and \c value will be transferred to this object on success.
        -: 1359:        \pre  IsObject() && name.IsString()
        -: 1360:        \post name.IsNull() && value.IsNull()
        -: 1361:        \note Amortized Constant time complexity.
        -: 1362:    */
        -: 1363:    GenericValue& AddMember(GenericValue& name, GenericValue& value, Allocator& allocator) {
        -: 1364:        RAPIDJSON_ASSERT(IsObject());
        -: 1365:        RAPIDJSON_ASSERT(name.IsString());
        -: 1366:        DoAddMember(name, value, allocator);
        -: 1367:        return *this;
        -: 1368:    }
        -: 1369:
        -: 1370:    //! Add a constant string value as member (name-value pair) to the object.
        -: 1371:    /*! \param name A string value as name of member.
        -: 1372:        \param value constant string reference as value of member.
        -: 1373:        \param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator().
        -: 1374:        \return The value itself for fluent API.
        -: 1375:        \pre  IsObject()
        -: 1376:        \note This overload is needed to avoid clashes with the generic primitive type AddMember(GenericValue&,T,Allocator&) overload below.
        -: 1377:        \note Amortized Constant time complexity.
        -: 1378:    */
        -: 1379:    GenericValue& AddMember(GenericValue& name, StringRefType value, Allocator& allocator) {
        -: 1380:        GenericValue v(value);
        -: 1381:        return AddMember(name, v, allocator);
        -: 1382:    }
        -: 1383:
        -: 1384:#if RAPIDJSON_HAS_STDSTRING
        -: 1385:    //! Add a string object as member (name-value pair) to the object.
        -: 1386:    /*! \param name A string value as name of member.
        -: 1387:        \param value constant string reference as value of member.
        -: 1388:        \param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator().
        -: 1389:        \return The value itself for fluent API.
        -: 1390:        \pre  IsObject()
        -: 1391:        \note This overload is needed to avoid clashes with the generic primitive type AddMember(GenericValue&,T,Allocator&) overload below.
        -: 1392:        \note Amortized Constant time complexity.
        -: 1393:    */
        -: 1394:    GenericValue& AddMember(GenericValue& name, std::basic_string<Ch>& value, Allocator& allocator) {
        -: 1395:        GenericValue v(value, allocator);
        -: 1396:        return AddMember(name, v, allocator);
        -: 1397:    }
        -: 1398:#endif
        -: 1399:
        -: 1400:    //! Add any primitive value as member (name-value pair) to the object.
        -: 1401:    /*! \tparam T Either \ref Type, \c int, \c unsigned, \c int64_t, \c uint64_t
        -: 1402:        \param name A string value as name of member.
        -: 1403:        \param value Value of primitive type \c T as value of member
        -: 1404:        \param allocator Allocator for reallocating memory. Commonly use GenericDocument::GetAllocator().
        -: 1405:        \return The value itself for fluent API.
        -: 1406:        \pre  IsObject()
        -: 1407:
        -: 1408:        \note The source type \c T explicitly disallows all pointer types,
        -: 1409:            especially (\c const) \ref Ch*.  This helps avoiding implicitly
        -: 1410:            referencing character strings with insufficient lifetime, use
        -: 1411:            \ref AddMember(StringRefType, GenericValue&, Allocator&) or \ref
        -: 1412:            AddMember(StringRefType, StringRefType, Allocator&).
        -: 1413:            All other pointer types would implicitly convert to \c bool,
        -: 1414:            use an explicit cast instead, if needed.
        -: 1415:        \note Amortized Constant time complexity.
        -: 1416:    */
        -: 1417:    template <typename T>
        -: 1418:    RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))
        -: 1419:    AddMember(GenericValue& name, T value, Allocator& allocator) {
        -: 1420:        GenericValue v(value);
        -: 1421:        return AddMember(name, v, allocator);
        -: 1422:    }
        -: 1423:
        -: 1424:#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -: 1425:    GenericValue& AddMember(GenericValue&& name, GenericValue&& value, Allocator& allocator) {
        -: 1426:        return AddMember(name, value, allocator);
        -: 1427:    }
        -: 1428:    GenericValue& AddMember(GenericValue&& name, GenericValue& value, Allocator& allocator) {
        -: 1429:        return AddMember(name, value, allocator);
        -: 1430:    }
        -: 1431:    GenericValue& AddMember(GenericValue& name, GenericValue&& value, Allocator& allocator) {
        -: 1432:        return AddMember(name, value, allocator);
        -: 1433:    }
        -: 1434:    GenericValue& AddMember(StringRefType name, GenericValue&& value, Allocator& allocator) {
        -: 1435:        GenericValue n(name);
        -: 1436:        return AddMember(n, value, allocator);
        -: 1437:    }
        -: 1438:#endif // RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -: 1439:
        -: 1440:
        -: 1441:    //! Add a member (name-value pair) to the object.
        -: 1442:    /*! \param name A constant string reference as name of member.
        -: 1443:        \param value Value of any type.
        -: 1444:        \param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator().
        -: 1445:        \return The value itself for fluent API.
        -: 1446:        \note The ownership of \c value will be transferred to this object on success.
        -: 1447:        \pre  IsObject()
        -: 1448:        \post value.IsNull()
        -: 1449:        \note Amortized Constant time complexity.
        -: 1450:    */
        -: 1451:    GenericValue& AddMember(StringRefType name, GenericValue& value, Allocator& allocator) {
        -: 1452:        GenericValue n(name);
        -: 1453:        return AddMember(n, value, allocator);
        -: 1454:    }
        -: 1455:
        -: 1456:    //! Add a constant string value as member (name-value pair) to the object.
        -: 1457:    /*! \param name A constant string reference as name of member.
        -: 1458:        \param value constant string reference as value of member.
        -: 1459:        \param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator().
        -: 1460:        \return The value itself for fluent API.
        -: 1461:        \pre  IsObject()
        -: 1462:        \note This overload is needed to avoid clashes with the generic primitive type AddMember(StringRefType,T,Allocator&) overload below.
        -: 1463:        \note Amortized Constant time complexity.
        -: 1464:    */
        -: 1465:    GenericValue& AddMember(StringRefType name, StringRefType value, Allocator& allocator) {
        -: 1466:        GenericValue v(value);
        -: 1467:        return AddMember(name, v, allocator);
        -: 1468:    }
        -: 1469:
        -: 1470:    //! Add any primitive value as member (name-value pair) to the object.
        -: 1471:    /*! \tparam T Either \ref Type, \c int, \c unsigned, \c int64_t, \c uint64_t
        -: 1472:        \param name A constant string reference as name of member.
        -: 1473:        \param value Value of primitive type \c T as value of member
        -: 1474:        \param allocator Allocator for reallocating memory. Commonly use GenericDocument::GetAllocator().
        -: 1475:        \return The value itself for fluent API.
        -: 1476:        \pre  IsObject()
        -: 1477:
        -: 1478:        \note The source type \c T explicitly disallows all pointer types,
        -: 1479:            especially (\c const) \ref Ch*.  This helps avoiding implicitly
        -: 1480:            referencing character strings with insufficient lifetime, use
        -: 1481:            \ref AddMember(StringRefType, GenericValue&, Allocator&) or \ref
        -: 1482:            AddMember(StringRefType, StringRefType, Allocator&).
        -: 1483:            All other pointer types would implicitly convert to \c bool,
        -: 1484:            use an explicit cast instead, if needed.
        -: 1485:        \note Amortized Constant time complexity.
        -: 1486:    */
        -: 1487:    template <typename T>
        -: 1488:    RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))
        -: 1489:    AddMember(StringRefType name, T value, Allocator& allocator) {
        -: 1490:        GenericValue n(name);
        -: 1491:        return AddMember(n, value, allocator);
        -: 1492:    }
        -: 1493:
        -: 1494:    //! Remove all members in the object.
        -: 1495:    /*! This function do not deallocate memory in the object, i.e. the capacity is unchanged.
        -: 1496:        \note Linear time complexity.
        -: 1497:    */
        -: 1498:    void RemoveAllMembers() {
        -: 1499:        RAPIDJSON_ASSERT(IsObject()); 
        -: 1500:        DoClearMembers();
        -: 1501:    }
        -: 1502:
        -: 1503:    //! Remove a member in object by its name.
        -: 1504:    /*! \param name Name of member to be removed.
        -: 1505:        \return Whether the member existed.
        -: 1506:        \note This function may reorder the object members. Use \ref
        -: 1507:            EraseMember(ConstMemberIterator) if you need to preserve the
        -: 1508:            relative order of the remaining members.
        -: 1509:        \note Linear time complexity.
        -: 1510:    */
        -: 1511:    bool RemoveMember(const Ch* name) {
        -: 1512:        GenericValue n(StringRef(name));
        -: 1513:        return RemoveMember(n);
        -: 1514:    }
        -: 1515:
        -: 1516:#if RAPIDJSON_HAS_STDSTRING
        -: 1517:    bool RemoveMember(const std::basic_string<Ch>& name) { return RemoveMember(GenericValue(StringRef(name))); }
        -: 1518:#endif
        -: 1519:
        -: 1520:    template <typename SourceAllocator>
        -: 1521:    bool RemoveMember(const GenericValue<Encoding, SourceAllocator>& name) {
        -: 1522:        MemberIterator m = FindMember(name);
        -: 1523:        if (m != MemberEnd()) {
        -: 1524:            RemoveMember(m);
        -: 1525:            return true;
        -: 1526:        }
        -: 1527:        else
        -: 1528:            return false;
        -: 1529:    }
        -: 1530:
        -: 1531:    //! Remove a member in object by iterator.
        -: 1532:    /*! \param m member iterator (obtained by FindMember() or MemberBegin()).
        -: 1533:        \return the new iterator after removal.
        -: 1534:        \note This function may reorder the object members. Use \ref
        -: 1535:            EraseMember(ConstMemberIterator) if you need to preserve the
        -: 1536:            relative order of the remaining members.
        -: 1537:        \note Constant time complexity.
        -: 1538:    */
        -: 1539:    MemberIterator RemoveMember(MemberIterator m) {
        -: 1540:        RAPIDJSON_ASSERT(IsObject());
        -: 1541:        RAPIDJSON_ASSERT(data_.o.size > 0);
        -: 1542:        RAPIDJSON_ASSERT(GetMembersPointer() != 0);
        -: 1543:        RAPIDJSON_ASSERT(m >= MemberBegin() && m < MemberEnd());
        -: 1544:        return DoRemoveMember(m);
        -: 1545:    }
        -: 1546:
        -: 1547:    //! Remove a member from an object by iterator.
        -: 1548:    /*! \param pos iterator to the member to remove
        -: 1549:        \pre IsObject() == true && \ref MemberBegin() <= \c pos < \ref MemberEnd()
        -: 1550:        \return Iterator following the removed element.
        -: 1551:            If the iterator \c pos refers to the last element, the \ref MemberEnd() iterator is returned.
        -: 1552:        \note This function preserves the relative order of the remaining object
        -: 1553:            members. If you do not need this, use the more efficient \ref RemoveMember(MemberIterator).
        -: 1554:        \note Linear time complexity.
        -: 1555:    */
        -: 1556:    MemberIterator EraseMember(ConstMemberIterator pos) {
        -: 1557:        return EraseMember(pos, pos +1);
        -: 1558:    }
        -: 1559:
        -: 1560:    //! Remove members in the range [first, last) from an object.
        -: 1561:    /*! \param first iterator to the first member to remove
        -: 1562:        \param last  iterator following the last member to remove
        -: 1563:        \pre IsObject() == true && \ref MemberBegin() <= \c first <= \c last <= \ref MemberEnd()
        -: 1564:        \return Iterator following the last removed element.
        -: 1565:        \note This function preserves the relative order of the remaining object
        -: 1566:            members.
        -: 1567:        \note Linear time complexity.
        -: 1568:    */
        -: 1569:    MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) {
        -: 1570:        RAPIDJSON_ASSERT(IsObject());
        -: 1571:        RAPIDJSON_ASSERT(data_.o.size > 0);
        -: 1572:        RAPIDJSON_ASSERT(GetMembersPointer() != 0);
        -: 1573:        RAPIDJSON_ASSERT(first >= MemberBegin());
        -: 1574:        RAPIDJSON_ASSERT(first <= last);
        -: 1575:        RAPIDJSON_ASSERT(last <= MemberEnd());
        -: 1576:        return DoEraseMembers(first, last);
        -: 1577:    }
        -: 1578:
        -: 1579:    //! Erase a member in object by its name.
        -: 1580:    /*! \param name Name of member to be removed.
        -: 1581:        \return Whether the member existed.
        -: 1582:        \note Linear time complexity.
        -: 1583:    */
        -: 1584:    bool EraseMember(const Ch* name) {
        -: 1585:        GenericValue n(StringRef(name));
        -: 1586:        return EraseMember(n);
        -: 1587:    }
        -: 1588:
        -: 1589:#if RAPIDJSON_HAS_STDSTRING
        -: 1590:    bool EraseMember(const std::basic_string<Ch>& name) { return EraseMember(GenericValue(StringRef(name))); }
        -: 1591:#endif
        -: 1592:
        -: 1593:    template <typename SourceAllocator>
        -: 1594:    bool EraseMember(const GenericValue<Encoding, SourceAllocator>& name) {
        -: 1595:        MemberIterator m = FindMember(name);
        -: 1596:        if (m != MemberEnd()) {
        -: 1597:            EraseMember(m);
        -: 1598:            return true;
        -: 1599:        }
        -: 1600:        else
        -: 1601:            return false;
        -: 1602:    }
        -: 1603:
        -: 1604:    Object GetObject() { RAPIDJSON_ASSERT(IsObject()); return Object(*this); }
        -: 1605:    ConstObject GetObject() const { RAPIDJSON_ASSERT(IsObject()); return ConstObject(*this); }
        -: 1606:
        -: 1607:    //@}
        -: 1608:
        -: 1609:    //!@name Array
        -: 1610:    //@{
        -: 1611:
        -: 1612:    //! Set this value as an empty array.
        -: 1613:    /*! \post IsArray == true */
        -: 1614:    GenericValue& SetArray() { this->~GenericValue(); new (this) GenericValue(kArrayType); return *this; }
        -: 1615:
        -: 1616:    //! Get the number of elements in array.
        -: 1617:    SizeType Size() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.size; }
        -: 1618:
        -: 1619:    //! Get the capacity of array.
        -: 1620:    SizeType Capacity() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.capacity; }
        -: 1621:
        -: 1622:    //! Check whether the array is empty.
        -: 1623:    bool Empty() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.size == 0; }
        -: 1624:
        -: 1625:    //! Remove all elements in the array.
        -: 1626:    /*! This function do not deallocate memory in the array, i.e. the capacity is unchanged.
        -: 1627:        \note Linear time complexity.
        -: 1628:    */
        -: 1629:    void Clear() {
        -: 1630:        RAPIDJSON_ASSERT(IsArray()); 
        -: 1631:        GenericValue* e = GetElementsPointer();
        -: 1632:        for (GenericValue* v = e; v != e + data_.a.size; ++v)
        -: 1633:            v->~GenericValue();
        -: 1634:        data_.a.size = 0;
        -: 1635:    }
        -: 1636:
        -: 1637:    //! Get an element from array by index.
        -: 1638:    /*! \pre IsArray() == true
        -: 1639:        \param index Zero-based index of element.
        -: 1640:        \see operator[](T*)
        -: 1641:    */
        -: 1642:    GenericValue& operator[](SizeType index) {
        -: 1643:        RAPIDJSON_ASSERT(IsArray());
        -: 1644:        RAPIDJSON_ASSERT(index < data_.a.size);
        -: 1645:        return GetElementsPointer()[index];
        -: 1646:    }
        -: 1647:    const GenericValue& operator[](SizeType index) const { return const_cast<GenericValue&>(*this)[index]; }
        -: 1648:
        -: 1649:    //! Element iterator
        -: 1650:    /*! \pre IsArray() == true */
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE5BeginEv called 15 returned 100% blocks executed 80%
      15*: 1651:    ValueIterator Begin() { RAPIDJSON_ASSERT(IsArray()); return GetElementsPointer(); }
       15: 1651-block  0
call    0 returned 15
branch  1 taken 0 (fallthrough)
branch  2 taken 15
    %%%%%: 1651-block  1
call    3 never executed
       15: 1651-block  2
call    4 returned 15
        -: 1652:    //! \em Past-the-end element iterator
        -: 1653:    /*! \pre IsArray() == true */
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE3EndEv called 15 returned 100% blocks executed 83%
      15*: 1654:    ValueIterator End() { RAPIDJSON_ASSERT(IsArray()); return GetElementsPointer() + data_.a.size; }
       15: 1654-block  0
call    0 returned 15
branch  1 taken 0 (fallthrough)
branch  2 taken 15
    %%%%%: 1654-block  1
call    3 never executed
       15: 1654-block  2
call    4 returned 15
        -: 1655:    //! Constant element iterator
        -: 1656:    /*! \pre IsArray() == true */
        -: 1657:    ConstValueIterator Begin() const { return const_cast<GenericValue&>(*this).Begin(); }
        -: 1658:    //! Constant \em past-the-end element iterator
        -: 1659:    /*! \pre IsArray() == true */
        -: 1660:    ConstValueIterator End() const { return const_cast<GenericValue&>(*this).End(); }
        -: 1661:
        -: 1662:    //! Request the array to have enough capacity to store elements.
        -: 1663:    /*! \param newCapacity  The capacity that the array at least need to have.
        -: 1664:        \param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator().
        -: 1665:        \return The value itself for fluent API.
        -: 1666:        \note Linear time complexity.
        -: 1667:    */
        -: 1668:    GenericValue& Reserve(SizeType newCapacity, Allocator &allocator) {
        -: 1669:        RAPIDJSON_ASSERT(IsArray());
        -: 1670:        if (newCapacity > data_.a.capacity) {
        -: 1671:            SetElementsPointer(reinterpret_cast<GenericValue*>(allocator.Realloc(GetElementsPointer(), data_.a.capacity * sizeof(GenericValue), newCapacity * sizeof(GenericValue))));
        -: 1672:            data_.a.capacity = newCapacity;
        -: 1673:        }
        -: 1674:        return *this;
        -: 1675:    }
        -: 1676:
        -: 1677:    //! Append a GenericValue at the end of the array.
        -: 1678:    /*! \param value        Value to be appended.
        -: 1679:        \param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator().
        -: 1680:        \pre IsArray() == true
        -: 1681:        \post value.IsNull() == true
        -: 1682:        \return The value itself for fluent API.
        -: 1683:        \note The ownership of \c value will be transferred to this array on success.
        -: 1684:        \note If the number of elements to be appended is known, calls Reserve() once first may be more efficient.
        -: 1685:        \note Amortized constant time complexity.
        -: 1686:    */
        -: 1687:    GenericValue& PushBack(GenericValue& value, Allocator& allocator) {
        -: 1688:        RAPIDJSON_ASSERT(IsArray());
        -: 1689:        if (data_.a.size >= data_.a.capacity)
        -: 1690:            Reserve(data_.a.capacity == 0 ? kDefaultArrayCapacity : (data_.a.capacity + (data_.a.capacity + 1) / 2), allocator);
        -: 1691:        GetElementsPointer()[data_.a.size++].RawAssign(value);
        -: 1692:        return *this;
        -: 1693:    }
        -: 1694:
        -: 1695:#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -: 1696:    GenericValue& PushBack(GenericValue&& value, Allocator& allocator) {
        -: 1697:        return PushBack(value, allocator);
        -: 1698:    }
        -: 1699:#endif // RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -: 1700:
        -: 1701:    //! Append a constant string reference at the end of the array.
        -: 1702:    /*! \param value        Constant string reference to be appended.
        -: 1703:        \param allocator    Allocator for reallocating memory. It must be the same one used previously. Commonly use GenericDocument::GetAllocator().
        -: 1704:        \pre IsArray() == true
        -: 1705:        \return The value itself for fluent API.
        -: 1706:        \note If the number of elements to be appended is known, calls Reserve() once first may be more efficient.
        -: 1707:        \note Amortized constant time complexity.
        -: 1708:        \see GenericStringRef
        -: 1709:    */
        -: 1710:    GenericValue& PushBack(StringRefType value, Allocator& allocator) {
        -: 1711:        return (*this).template PushBack<StringRefType>(value, allocator);
        -: 1712:    }
        -: 1713:
        -: 1714:    //! Append a primitive value at the end of the array.
        -: 1715:    /*! \tparam T Either \ref Type, \c int, \c unsigned, \c int64_t, \c uint64_t
        -: 1716:        \param value Value of primitive type T to be appended.
        -: 1717:        \param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator().
        -: 1718:        \pre IsArray() == true
        -: 1719:        \return The value itself for fluent API.
        -: 1720:        \note If the number of elements to be appended is known, calls Reserve() once first may be more efficient.
        -: 1721:
        -: 1722:        \note The source type \c T explicitly disallows all pointer types,
        -: 1723:            especially (\c const) \ref Ch*.  This helps avoiding implicitly
        -: 1724:            referencing character strings with insufficient lifetime, use
        -: 1725:            \ref PushBack(GenericValue&, Allocator&) or \ref
        -: 1726:            PushBack(StringRefType, Allocator&).
        -: 1727:            All other pointer types would implicitly convert to \c bool,
        -: 1728:            use an explicit cast instead, if needed.
        -: 1729:        \note Amortized constant time complexity.
        -: 1730:    */
        -: 1731:    template <typename T>
        -: 1732:    RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))
        -: 1733:    PushBack(T value, Allocator& allocator) {
        -: 1734:        GenericValue v(value);
        -: 1735:        return PushBack(v, allocator);
        -: 1736:    }
        -: 1737:
        -: 1738:    //! Remove the last element in the array.
        -: 1739:    /*!
        -: 1740:        \note Constant time complexity.
        -: 1741:    */
        -: 1742:    GenericValue& PopBack() {
        -: 1743:        RAPIDJSON_ASSERT(IsArray());
        -: 1744:        RAPIDJSON_ASSERT(!Empty());
        -: 1745:        GetElementsPointer()[--data_.a.size].~GenericValue();
        -: 1746:        return *this;
        -: 1747:    }
        -: 1748:
        -: 1749:    //! Remove an element of array by iterator.
        -: 1750:    /*!
        -: 1751:        \param pos iterator to the element to remove
        -: 1752:        \pre IsArray() == true && \ref Begin() <= \c pos < \ref End()
        -: 1753:        \return Iterator following the removed element. If the iterator pos refers to the last element, the End() iterator is returned.
        -: 1754:        \note Linear time complexity.
        -: 1755:    */
        -: 1756:    ValueIterator Erase(ConstValueIterator pos) {
        -: 1757:        return Erase(pos, pos + 1);
        -: 1758:    }
        -: 1759:
        -: 1760:    //! Remove elements in the range [first, last) of the array.
        -: 1761:    /*!
        -: 1762:        \param first iterator to the first element to remove
        -: 1763:        \param last  iterator following the last element to remove
        -: 1764:        \pre IsArray() == true && \ref Begin() <= \c first <= \c last <= \ref End()
        -: 1765:        \return Iterator following the last removed element.
        -: 1766:        \note Linear time complexity.
        -: 1767:    */
        -: 1768:    ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) {
        -: 1769:        RAPIDJSON_ASSERT(IsArray());
        -: 1770:        RAPIDJSON_ASSERT(data_.a.size > 0);
        -: 1771:        RAPIDJSON_ASSERT(GetElementsPointer() != 0);
        -: 1772:        RAPIDJSON_ASSERT(first >= Begin());
        -: 1773:        RAPIDJSON_ASSERT(first <= last);
        -: 1774:        RAPIDJSON_ASSERT(last <= End());
        -: 1775:        ValueIterator pos = Begin() + (first - Begin());
        -: 1776:        for (ValueIterator itr = pos; itr != last; ++itr)
        -: 1777:            itr->~GenericValue();
        -: 1778:        std::memmove(static_cast<void*>(pos), last, static_cast<size_t>(End() - last) * sizeof(GenericValue));
        -: 1779:        data_.a.size -= static_cast<SizeType>(last - first);
        -: 1780:        return pos;
        -: 1781:    }
        -: 1782:
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE8GetArrayEv called 15 returned 100% blocks executed 80%
      15*: 1783:    Array GetArray() { RAPIDJSON_ASSERT(IsArray()); return Array(*this); }
       15: 1783-block  0
call    0 returned 15
branch  1 taken 0 (fallthrough)
branch  2 taken 15
    %%%%%: 1783-block  1
call    3 never executed
       15: 1783-block  2
call    4 returned 15
        -: 1784:    ConstArray GetArray() const { RAPIDJSON_ASSERT(IsArray()); return ConstArray(*this); }
        -: 1785:
        -: 1786:    //@}
        -: 1787:
        -: 1788:    //!@name Number
        -: 1789:    //@{
        -: 1790:
        -: 1791:    int GetInt() const          { RAPIDJSON_ASSERT(data_.f.flags & kIntFlag);   return data_.n.i.i;   }
        -: 1792:    unsigned GetUint() const    { RAPIDJSON_ASSERT(data_.f.flags & kUintFlag);  return data_.n.u.u;   }
        -: 1793:    int64_t GetInt64() const    { RAPIDJSON_ASSERT(data_.f.flags & kInt64Flag); return data_.n.i64; }
        -: 1794:    uint64_t GetUint64() const  { RAPIDJSON_ASSERT(data_.f.flags & kUint64Flag); return data_.n.u64; }
        -: 1795:
        -: 1796:    //! Get the value as double type.
        -: 1797:    /*! \note If the value is 64-bit integer type, it may lose precision. Use \c IsLosslessDouble() to check whether the converison is lossless.
        -: 1798:    */
        -: 1799:    double GetDouble() const {
        -: 1800:        RAPIDJSON_ASSERT(IsNumber());
        -: 1801:        if ((data_.f.flags & kDoubleFlag) != 0)                return data_.n.d;   // exact type, no conversion.
        -: 1802:        if ((data_.f.flags & kIntFlag) != 0)                   return data_.n.i.i; // int -> double
        -: 1803:        if ((data_.f.flags & kUintFlag) != 0)                  return data_.n.u.u; // unsigned -> double
        -: 1804:        if ((data_.f.flags & kInt64Flag) != 0)                 return static_cast<double>(data_.n.i64); // int64_t -> double (may lose precision)
        -: 1805:        RAPIDJSON_ASSERT((data_.f.flags & kUint64Flag) != 0);  return static_cast<double>(data_.n.u64); // uint64_t -> double (may lose precision)
        -: 1806:    }
        -: 1807:
        -: 1808:    //! Get the value as float type.
        -: 1809:    /*! \note If the value is 64-bit integer type, it may lose precision. Use \c IsLosslessFloat() to check whether the converison is lossless.
        -: 1810:    */
        -: 1811:    float GetFloat() const {
        -: 1812:        return static_cast<float>(GetDouble());
        -: 1813:    }
        -: 1814:
        -: 1815:    GenericValue& SetInt(int i)             { this->~GenericValue(); new (this) GenericValue(i);    return *this; }
        -: 1816:    GenericValue& SetUint(unsigned u)       { this->~GenericValue(); new (this) GenericValue(u);    return *this; }
        -: 1817:    GenericValue& SetInt64(int64_t i64)     { this->~GenericValue(); new (this) GenericValue(i64);  return *this; }
        -: 1818:    GenericValue& SetUint64(uint64_t u64)   { this->~GenericValue(); new (this) GenericValue(u64);  return *this; }
        -: 1819:    GenericValue& SetDouble(double d)       { this->~GenericValue(); new (this) GenericValue(d);    return *this; }
        -: 1820:    GenericValue& SetFloat(float f)         { this->~GenericValue(); new (this) GenericValue(static_cast<double>(f)); return *this; }
        -: 1821:
        -: 1822:    //@}
        -: 1823:
        -: 1824:    //!@name String
        -: 1825:    //@{
        -: 1826:
function _ZNK9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE9GetStringEv called 777 returned 100% blocks executed 80%
     777*: 1827:    const Ch* GetString() const { RAPIDJSON_ASSERT(IsString()); return DataString(data_); }
      777: 1827-block  0
call    0 returned 777
branch  1 taken 0 (fallthrough)
branch  2 taken 777
    %%%%%: 1827-block  1
call    3 never executed
      777: 1827-block  2
call    4 returned 777
        -: 1828:
        -: 1829:    //! Get the length of string.
        -: 1830:    /*! Since rapidjson permits "\\u0000" in the json string, strlen(v.GetString()) may not equal to v.GetStringLength().
        -: 1831:    */
function _ZNK9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE15GetStringLengthEv called 898 returned 100% blocks executed 83%
     898*: 1832:    SizeType GetStringLength() const { RAPIDJSON_ASSERT(IsString()); return DataStringLength(data_); }
      898: 1832-block  0
call    0 returned 898
branch  1 taken 0 (fallthrough)
branch  2 taken 898
    %%%%%: 1832-block  1
call    3 never executed
      898: 1832-block  2
call    4 returned 898
        -: 1833:
        -: 1834:    //! Set this value as a string without copying source string.
        -: 1835:    /*! This version has better performance with supplied length, and also support string containing null character.
        -: 1836:        \param s source string pointer. 
        -: 1837:        \param length The length of source string, excluding the trailing null terminator.
        -: 1838:        \return The value itself for fluent API.
        -: 1839:        \post IsString() == true && GetString() == s && GetStringLength() == length
        -: 1840:        \see SetString(StringRefType)
        -: 1841:    */
        -: 1842:    GenericValue& SetString(const Ch* s, SizeType length) { return SetString(StringRef(s, length)); }
        -: 1843:
        -: 1844:    //! Set this value as a string without copying source string.
        -: 1845:    /*! \param s source string reference
        -: 1846:        \return The value itself for fluent API.
        -: 1847:        \post IsString() == true && GetString() == s && GetStringLength() == s.length
        -: 1848:    */
        -: 1849:    GenericValue& SetString(StringRefType s) { this->~GenericValue(); SetStringRaw(s); return *this; }
        -: 1850:
        -: 1851:    //! Set this value as a string by copying from source string.
        -: 1852:    /*! This version has better performance with supplied length, and also support string containing null character.
        -: 1853:        \param s source string. 
        -: 1854:        \param length The length of source string, excluding the trailing null terminator.
        -: 1855:        \param allocator Allocator for allocating copied buffer. Commonly use GenericDocument::GetAllocator().
        -: 1856:        \return The value itself for fluent API.
        -: 1857:        \post IsString() == true && GetString() != s && strcmp(GetString(),s) == 0 && GetStringLength() == length
        -: 1858:    */
        -: 1859:    GenericValue& SetString(const Ch* s, SizeType length, Allocator& allocator) { return SetString(StringRef(s, length), allocator); }
        -: 1860:
        -: 1861:    //! Set this value as a string by copying from source string.
        -: 1862:    /*! \param s source string. 
        -: 1863:        \param allocator Allocator for allocating copied buffer. Commonly use GenericDocument::GetAllocator().
        -: 1864:        \return The value itself for fluent API.
        -: 1865:        \post IsString() == true && GetString() != s && strcmp(GetString(),s) == 0 && GetStringLength() == length
        -: 1866:    */
        -: 1867:    GenericValue& SetString(const Ch* s, Allocator& allocator) { return SetString(StringRef(s), allocator); }
        -: 1868:
        -: 1869:    //! Set this value as a string by copying from source string.
        -: 1870:    /*! \param s source string reference
        -: 1871:        \param allocator Allocator for allocating copied buffer. Commonly use GenericDocument::GetAllocator().
        -: 1872:        \return The value itself for fluent API.
        -: 1873:        \post IsString() == true && GetString() != s.s && strcmp(GetString(),s) == 0 && GetStringLength() == length
        -: 1874:    */
        -: 1875:    GenericValue& SetString(StringRefType s, Allocator& allocator) { this->~GenericValue(); SetStringRaw(s, allocator); return *this; }
        -: 1876:
        -: 1877:#if RAPIDJSON_HAS_STDSTRING
        -: 1878:    //! Set this value as a string by copying from source string.
        -: 1879:    /*! \param s source string.
        -: 1880:        \param allocator Allocator for allocating copied buffer. Commonly use GenericDocument::GetAllocator().
        -: 1881:        \return The value itself for fluent API.
        -: 1882:        \post IsString() == true && GetString() != s.data() && strcmp(GetString(),s.data() == 0 && GetStringLength() == s.size()
        -: 1883:        \note Requires the definition of the preprocessor symbol \ref RAPIDJSON_HAS_STDSTRING.
        -: 1884:    */
        -: 1885:    GenericValue& SetString(const std::basic_string<Ch>& s, Allocator& allocator) { return SetString(StringRef(s), allocator); }
        -: 1886:#endif
        -: 1887:
        -: 1888:    //@}
        -: 1889:
        -: 1890:    //!@name Array
        -: 1891:    //@{
        -: 1892:
        -: 1893:    //! Templated version for checking whether this value is type T.
        -: 1894:    /*!
        -: 1895:        \tparam T Either \c bool, \c int, \c unsigned, \c int64_t, \c uint64_t, \c double, \c float, \c const \c char*, \c std::basic_string<Ch>
        -: 1896:    */
        -: 1897:    template <typename T>
        -: 1898:    bool Is() const { return internal::TypeHelper<ValueType, T>::Is(*this); }
        -: 1899:
        -: 1900:    template <typename T>
        -: 1901:    T Get() const { return internal::TypeHelper<ValueType, T>::Get(*this); }
        -: 1902:
        -: 1903:    template <typename T>
        -: 1904:    T Get() { return internal::TypeHelper<ValueType, T>::Get(*this); }
        -: 1905:
        -: 1906:    template<typename T>
        -: 1907:    ValueType& Set(const T& data) { return internal::TypeHelper<ValueType, T>::Set(*this, data); }
        -: 1908:
        -: 1909:    template<typename T>
        -: 1910:    ValueType& Set(const T& data, AllocatorType& allocator) { return internal::TypeHelper<ValueType, T>::Set(*this, data, allocator); }
        -: 1911:
        -: 1912:    //@}
        -: 1913:
        -: 1914:    //! Generate events of this value to a Handler.
        -: 1915:    /*! This function adopts the GoF visitor pattern.
        -: 1916:        Typical usage is to output this JSON value as JSON text via Writer, which is a Handler.
        -: 1917:        It can also be used to deep clone this value via GenericDocument, which is also a Handler.
        -: 1918:        \tparam Handler type of handler.
        -: 1919:        \param handler An object implementing concept Handler.
        -: 1920:    */
        -: 1921:    template <typename Handler>
        -: 1922:    bool Accept(Handler& handler) const {
        -: 1923:        switch(GetType()) {
        -: 1924:        case kNullType:     return handler.Null();
        -: 1925:        case kFalseType:    return handler.Bool(false);
        -: 1926:        case kTrueType:     return handler.Bool(true);
        -: 1927:
        -: 1928:        case kObjectType:
        -: 1929:            if (RAPIDJSON_UNLIKELY(!handler.StartObject()))
        -: 1930:                return false;
        -: 1931:            for (ConstMemberIterator m = MemberBegin(); m != MemberEnd(); ++m) {
        -: 1932:                RAPIDJSON_ASSERT(m->name.IsString()); // User may change the type of name by MemberIterator.
        -: 1933:                if (RAPIDJSON_UNLIKELY(!handler.Key(m->name.GetString(), m->name.GetStringLength(), (m->name.data_.f.flags & kCopyFlag) != 0)))
        -: 1934:                    return false;
        -: 1935:                if (RAPIDJSON_UNLIKELY(!m->value.Accept(handler)))
        -: 1936:                    return false;
        -: 1937:            }
        -: 1938:            return handler.EndObject(data_.o.size);
        -: 1939:
        -: 1940:        case kArrayType:
        -: 1941:            if (RAPIDJSON_UNLIKELY(!handler.StartArray()))
        -: 1942:                return false;
        -: 1943:            for (const GenericValue* v = Begin(); v != End(); ++v)
        -: 1944:                if (RAPIDJSON_UNLIKELY(!v->Accept(handler)))
        -: 1945:                    return false;
        -: 1946:            return handler.EndArray(data_.a.size);
        -: 1947:    
        -: 1948:        case kStringType:
        -: 1949:            return handler.String(GetString(), GetStringLength(), (data_.f.flags & kCopyFlag) != 0);
        -: 1950:    
        -: 1951:        default:
        -: 1952:            RAPIDJSON_ASSERT(GetType() == kNumberType);
        -: 1953:            if (IsDouble())         return handler.Double(data_.n.d);
        -: 1954:            else if (IsInt())       return handler.Int(data_.n.i.i);
        -: 1955:            else if (IsUint())      return handler.Uint(data_.n.u.u);
        -: 1956:            else if (IsInt64())     return handler.Int64(data_.n.i64);
        -: 1957:            else                    return handler.Uint64(data_.n.u64);
        -: 1958:        }
        -: 1959:    }
        -: 1960:
        -: 1961:private:
        -: 1962:    template <typename, typename> friend class GenericValue;
        -: 1963:    template <typename, typename, typename> friend class GenericDocument;
        -: 1964:
        -: 1965:    enum {
        -: 1966:        kBoolFlag       = 0x0008,
        -: 1967:        kNumberFlag     = 0x0010,
        -: 1968:        kIntFlag        = 0x0020,
        -: 1969:        kUintFlag       = 0x0040,
        -: 1970:        kInt64Flag      = 0x0080,
        -: 1971:        kUint64Flag     = 0x0100,
        -: 1972:        kDoubleFlag     = 0x0200,
        -: 1973:        kStringFlag     = 0x0400,
        -: 1974:        kCopyFlag       = 0x0800,
        -: 1975:        kInlineStrFlag  = 0x1000,
        -: 1976:
        -: 1977:        // Initial flags of different types.
        -: 1978:        kNullFlag = kNullType,
        -: 1979:        // These casts are added to suppress the warning on MSVC about bitwise operations between enums of different types.
        -: 1980:        kTrueFlag = static_cast<int>(kTrueType) | static_cast<int>(kBoolFlag),
        -: 1981:        kFalseFlag = static_cast<int>(kFalseType) | static_cast<int>(kBoolFlag),
        -: 1982:        kNumberIntFlag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kIntFlag | kInt64Flag),
        -: 1983:        kNumberUintFlag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kUintFlag | kUint64Flag | kInt64Flag),
        -: 1984:        kNumberInt64Flag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kInt64Flag),
        -: 1985:        kNumberUint64Flag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kUint64Flag),
        -: 1986:        kNumberDoubleFlag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kDoubleFlag),
        -: 1987:        kNumberAnyFlag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kIntFlag | kInt64Flag | kUintFlag | kUint64Flag | kDoubleFlag),
        -: 1988:        kConstStringFlag = static_cast<int>(kStringType) | static_cast<int>(kStringFlag),
        -: 1989:        kCopyStringFlag = static_cast<int>(kStringType) | static_cast<int>(kStringFlag | kCopyFlag),
        -: 1990:        kShortStringFlag = static_cast<int>(kStringType) | static_cast<int>(kStringFlag | kCopyFlag | kInlineStrFlag),
        -: 1991:        kObjectFlag = kObjectType,
        -: 1992:        kArrayFlag = kArrayType,
        -: 1993:
        -: 1994:        kTypeMask = 0x07
        -: 1995:    };
        -: 1996:
        -: 1997:    static const SizeType kDefaultArrayCapacity = RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY;
        -: 1998:    static const SizeType kDefaultObjectCapacity = RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY;
        -: 1999:
        -: 2000:    struct Flag {
        -: 2001:#if RAPIDJSON_48BITPOINTER_OPTIMIZATION
        -: 2002:        char payload[sizeof(SizeType) * 2 + 6];     // 2 x SizeType + lower 48-bit pointer
        -: 2003:#elif RAPIDJSON_64BIT
        -: 2004:        char payload[sizeof(SizeType) * 2 + sizeof(void*) + 6]; // 6 padding bytes
        -: 2005:#else
        -: 2006:        char payload[sizeof(SizeType) * 2 + sizeof(void*) + 2]; // 2 padding bytes
        -: 2007:#endif
        -: 2008:        uint16_t flags;
        -: 2009:    };
        -: 2010:
        -: 2011:    struct String {
        -: 2012:        SizeType length;
        -: 2013:        SizeType hashcode;  //!< reserved
        -: 2014:        const Ch* str;
        -: 2015:    };  // 12 bytes in 32-bit mode, 16 bytes in 64-bit mode
        -: 2016:
        -: 2017:    // implementation detail: ShortString can represent zero-terminated strings up to MaxSize chars
        -: 2018:    // (excluding the terminating zero) and store a value to determine the length of the contained
        -: 2019:    // string in the last character str[LenPos] by storing "MaxSize - length" there. If the string
        -: 2020:    // to store has the maximal length of MaxSize then str[LenPos] will be 0 and therefore act as
        -: 2021:    // the string terminator as well. For getting the string length back from that value just use
        -: 2022:    // "MaxSize - str[LenPos]".
        -: 2023:    // This allows to store 13-chars strings in 32-bit mode, 21-chars strings in 64-bit mode,
        -: 2024:    // 13-chars strings for RAPIDJSON_48BITPOINTER_OPTIMIZATION=1 inline (for `UTF8`-encoded strings).
        -: 2025:    struct ShortString {
        -: 2026:        enum { MaxChars = sizeof(static_cast<Flag*>(0)->payload) / sizeof(Ch), MaxSize = MaxChars - 1, LenPos = MaxSize };
        -: 2027:        Ch str[MaxChars];
        -: 2028:
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE11ShortString6UsableEj called 12824 returned 100% blocks executed 100%
    12824: 2029:        inline static bool Usable(SizeType len) { return                       (MaxSize >= len); }
    12824: 2029-block  0
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE11ShortString9SetLengthEj called 12187 returned 100% blocks executed 100%
    12187: 2030:        inline void     SetLength(SizeType len) { str[LenPos] = static_cast<Ch>(MaxSize -  len); }
function _ZNK9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE11ShortString9GetLengthEv called 449 returned 100% blocks executed 100%
      449: 2031:        inline SizeType GetLength() const       { return  static_cast<SizeType>(MaxSize -  str[LenPos]); }
      449: 2031-block  0
        -: 2032:    };  // at most as many bytes as "String" above => 12 bytes in 32-bit mode, 16 bytes in 64-bit mode
        -: 2033:
        -: 2034:    // By using proper binary layout, retrieval of different integer types do not need conversions.
        -: 2035:    union Number {
        -: 2036:#if RAPIDJSON_ENDIAN == RAPIDJSON_LITTLEENDIAN
        -: 2037:        struct I {
        -: 2038:            int i;
        -: 2039:            char padding[4];
        -: 2040:        }i;
        -: 2041:        struct U {
        -: 2042:            unsigned u;
        -: 2043:            char padding2[4];
        -: 2044:        }u;
        -: 2045:#else
        -: 2046:        struct I {
        -: 2047:            char padding[4];
        -: 2048:            int i;
        -: 2049:        }i;
        -: 2050:        struct U {
        -: 2051:            char padding2[4];
        -: 2052:            unsigned u;
        -: 2053:        }u;
        -: 2054:#endif
        -: 2055:        int64_t i64;
        -: 2056:        uint64_t u64;
        -: 2057:        double d;
        -: 2058:    };  // 8 bytes
        -: 2059:
        -: 2060:    struct ObjectData {
        -: 2061:        SizeType size;
        -: 2062:        SizeType capacity;
        -: 2063:        Member* members;
        -: 2064:    };  // 12 bytes in 32-bit mode, 16 bytes in 64-bit mode
        -: 2065:
        -: 2066:    struct ArrayData {
        -: 2067:        SizeType size;
        -: 2068:        SizeType capacity;
        -: 2069:        GenericValue* elements;
        -: 2070:    };  // 12 bytes in 32-bit mode, 16 bytes in 64-bit mode
        -: 2071:
        -: 2072:    union Data {
        -: 2073:        String s;
        -: 2074:        ShortString ss;
        -: 2075:        Number n;
        -: 2076:        ObjectData o;
        -: 2077:        ArrayData a;
        -: 2078:        Flag f;
        -: 2079:    };  // 16 bytes in 32-bit mode, 24 bytes in 64-bit mode, 16 bytes in 64-bit with RAPIDJSON_48BITPOINTER_OPTIMIZATION
        -: 2080:
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE10DataStringERKNS6_4DataE called 777 returned 100% blocks executed 100%
      777: 2081:    static RAPIDJSON_FORCEINLINE const Ch* DataString(const Data& data) {
      777: 2082:        return (data.f.flags & kInlineStrFlag) ? data.ss.str : RAPIDJSON_GETPOINTER(Ch, data.s.str);
      777: 2082-block  0
branch  0 taken 348 (fallthrough)
branch  1 taken 429
      348: 2082-block  1
      429: 2082-block  2
      777: 2082-block  3
        -: 2083:    }
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE16DataStringLengthERKNS6_4DataE called 898 returned 100% blocks executed 100%
      898: 2084:    static RAPIDJSON_FORCEINLINE SizeType DataStringLength(const Data& data) {
      898: 2085:        return (data.f.flags & kInlineStrFlag) ? data.ss.GetLength() : data.s.length;
      898: 2085-block  0
branch  0 taken 449 (fallthrough)
branch  1 taken 449
      449: 2085-block  1
call    2 returned 449
      449: 2085-block  2
      898: 2085-block  3
        -: 2086:    }
        -: 2087:
        -: 2088:    RAPIDJSON_FORCEINLINE const Ch* GetStringPointer() const { return RAPIDJSON_GETPOINTER(Ch, data_.s.str); }
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE16SetStringPointerEPKc called 886 returned 100% blocks executed 100%
      886: 2089:    RAPIDJSON_FORCEINLINE const Ch* SetStringPointer(const Ch* str) { return RAPIDJSON_SETPOINTER(Ch, data_.s.str, str); }
      886: 2089-block  0
function _ZNK9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE18GetElementsPointerEv called 30 returned 100% blocks executed 100%
       30: 2090:    RAPIDJSON_FORCEINLINE GenericValue* GetElementsPointer() const { return RAPIDJSON_GETPOINTER(GenericValue, data_.a.elements); }
       30: 2090-block  0
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE18SetElementsPointerEPS6_ called 1346 returned 100% blocks executed 100%
     1346: 2091:    RAPIDJSON_FORCEINLINE GenericValue* SetElementsPointer(GenericValue* elements) { return RAPIDJSON_SETPOINTER(GenericValue, data_.a.elements, elements); }
     1346: 2091-block  0
function _ZNK9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE17GetMembersPointerEv called 947 returned 100% blocks executed 100%
      947: 2092:    RAPIDJSON_FORCEINLINE Member* GetMembersPointer() const { return RAPIDJSON_GETPOINTER(Member, data_.o.members); }
      947: 2092-block  0
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE17SetMembersPointerEPNS_13GenericMemberIS2_S5_EE called 1821 returned 100% blocks executed 100%
     1821: 2093:    RAPIDJSON_FORCEINLINE Member* SetMembersPointer(Member* members) { return RAPIDJSON_SETPOINTER(Member, data_.o.members, members); }
     1821: 2093-block  0
        -: 2094:
        -: 2095:#if RAPIDJSON_USE_MEMBERSMAP
        -: 2096:
        -: 2097:    struct MapTraits {
        -: 2098:        struct Less {
        -: 2099:            bool operator()(const Data& s1, const Data& s2) const {
        -: 2100:                SizeType n1 = DataStringLength(s1), n2 = DataStringLength(s2);
        -: 2101:                int cmp = std::memcmp(DataString(s1), DataString(s2), sizeof(Ch) * (n1 < n2 ? n1 : n2));
        -: 2102:                return cmp < 0 || (cmp == 0 && n1 < n2);
        -: 2103:            }
        -: 2104:        };
        -: 2105:        typedef std::pair<const Data, SizeType> Pair;
        -: 2106:        typedef std::multimap<Data, SizeType, Less, StdAllocator<Pair, Allocator> > Map;
        -: 2107:        typedef typename Map::iterator Iterator;
        -: 2108:    };
        -: 2109:    typedef typename MapTraits::Map         Map;
        -: 2110:    typedef typename MapTraits::Less        MapLess;
        -: 2111:    typedef typename MapTraits::Pair        MapPair;
        -: 2112:    typedef typename MapTraits::Iterator    MapIterator;
        -: 2113:
        -: 2114:    //
        -: 2115:    // Layout of the members' map/array, re(al)located according to the needed capacity:
        -: 2116:    //
        -: 2117:    //    {Map*}<>{capacity}<>{Member[capacity]}<>{MapIterator[capacity]}
        -: 2118:    //
        -: 2119:    // (where <> stands for the RAPIDJSON_ALIGN-ment, if needed)
        -: 2120:    //
        -: 2121:
        -: 2122:    static RAPIDJSON_FORCEINLINE size_t GetMapLayoutSize(SizeType capacity) {
        -: 2123:        return RAPIDJSON_ALIGN(sizeof(Map*)) +
        -: 2124:               RAPIDJSON_ALIGN(sizeof(SizeType)) +
        -: 2125:               RAPIDJSON_ALIGN(capacity * sizeof(Member)) +
        -: 2126:               capacity * sizeof(MapIterator);
        -: 2127:    }
        -: 2128:
        -: 2129:    static RAPIDJSON_FORCEINLINE SizeType &GetMapCapacity(Map* &map) {
        -: 2130:        return *reinterpret_cast<SizeType*>(reinterpret_cast<uintptr_t>(&map) +
        -: 2131:                                            RAPIDJSON_ALIGN(sizeof(Map*)));
        -: 2132:    }
        -: 2133:
        -: 2134:    static RAPIDJSON_FORCEINLINE Member* GetMapMembers(Map* &map) {
        -: 2135:        return reinterpret_cast<Member*>(reinterpret_cast<uintptr_t>(&map) +
        -: 2136:                                         RAPIDJSON_ALIGN(sizeof(Map*)) +
        -: 2137:                                         RAPIDJSON_ALIGN(sizeof(SizeType)));
        -: 2138:    }
        -: 2139:
        -: 2140:    static RAPIDJSON_FORCEINLINE MapIterator* GetMapIterators(Map* &map) {
        -: 2141:        return reinterpret_cast<MapIterator*>(reinterpret_cast<uintptr_t>(&map) +
        -: 2142:                                              RAPIDJSON_ALIGN(sizeof(Map*)) +
        -: 2143:                                              RAPIDJSON_ALIGN(sizeof(SizeType)) +
        -: 2144:                                              RAPIDJSON_ALIGN(GetMapCapacity(map) * sizeof(Member)));
        -: 2145:    }
        -: 2146:
        -: 2147:    static RAPIDJSON_FORCEINLINE Map* &GetMap(Member* members) {
        -: 2148:        RAPIDJSON_ASSERT(members != 0);
        -: 2149:        return *reinterpret_cast<Map**>(reinterpret_cast<uintptr_t>(members) -
        -: 2150:                                        RAPIDJSON_ALIGN(sizeof(SizeType)) -
        -: 2151:                                        RAPIDJSON_ALIGN(sizeof(Map*)));
        -: 2152:    }
        -: 2153:
        -: 2154:    // Some compilers' debug mechanisms want all iterators to be destroyed, for their accounting..
        -: 2155:    RAPIDJSON_FORCEINLINE MapIterator DropMapIterator(MapIterator& rhs) {
        -: 2156:#if RAPIDJSON_HAS_CXX11
        -: 2157:        MapIterator ret = std::move(rhs);
        -: 2158:#else
        -: 2159:        MapIterator ret = rhs;
        -: 2160:#endif
        -: 2161:        rhs.~MapIterator();
        -: 2162:        return ret;
        -: 2163:    }
        -: 2164:
        -: 2165:    Map* &DoReallocMap(Map** oldMap, SizeType newCapacity, Allocator& allocator) {
        -: 2166:        Map **newMap = static_cast<Map**>(allocator.Malloc(GetMapLayoutSize(newCapacity)));
        -: 2167:        GetMapCapacity(*newMap) = newCapacity;
        -: 2168:        if (!oldMap) {
        -: 2169:            *newMap = new (allocator.Malloc(sizeof(Map))) Map(MapLess(), allocator);
        -: 2170:        }
        -: 2171:        else {
        -: 2172:            *newMap = *oldMap;
        -: 2173:            size_t count = (*oldMap)->size();
        -: 2174:            std::memcpy(static_cast<void*>(GetMapMembers(*newMap)),
        -: 2175:                        static_cast<void*>(GetMapMembers(*oldMap)),
        -: 2176:                        count * sizeof(Member));
        -: 2177:            MapIterator *oldIt = GetMapIterators(*oldMap),
        -: 2178:                        *newIt = GetMapIterators(*newMap);
        -: 2179:            while (count--) {
        -: 2180:                new (&newIt[count]) MapIterator(DropMapIterator(oldIt[count]));
        -: 2181:            }
        -: 2182:            Allocator::Free(oldMap);
        -: 2183:        }
        -: 2184:        return *newMap;
        -: 2185:    }
        -: 2186:
        -: 2187:    RAPIDJSON_FORCEINLINE Member* DoAllocMembers(SizeType capacity, Allocator& allocator) {
        -: 2188:        return GetMapMembers(DoReallocMap(0, capacity, allocator));
        -: 2189:    }
        -: 2190:
        -: 2191:    void DoReserveMembers(SizeType newCapacity, Allocator& allocator) {
        -: 2192:        ObjectData& o = data_.o;
        -: 2193:        if (newCapacity > o.capacity) {
        -: 2194:            Member* oldMembers = GetMembersPointer();
        -: 2195:            Map **oldMap = oldMembers ? &GetMap(oldMembers) : 0,
        -: 2196:                *&newMap = DoReallocMap(oldMap, newCapacity, allocator);
        -: 2197:            RAPIDJSON_SETPOINTER(Member, o.members, GetMapMembers(newMap));
        -: 2198:            o.capacity = newCapacity;
        -: 2199:        }
        -: 2200:    }
        -: 2201:
        -: 2202:    template <typename SourceAllocator>
        -: 2203:    MemberIterator DoFindMember(const GenericValue<Encoding, SourceAllocator>& name) {
        -: 2204:        if (Member* members = GetMembersPointer()) {
        -: 2205:            Map* &map = GetMap(members);
        -: 2206:            MapIterator mit = map->find(reinterpret_cast<const Data&>(name.data_));
        -: 2207:            if (mit != map->end()) {
        -: 2208:                return MemberIterator(&members[mit->second]);
        -: 2209:            }
        -: 2210:        }
        -: 2211:        return MemberEnd();
        -: 2212:    }
        -: 2213:
        -: 2214:    void DoClearMembers() {
        -: 2215:        if (Member* members = GetMembersPointer()) {
        -: 2216:            Map* &map = GetMap(members);
        -: 2217:            MapIterator* mit = GetMapIterators(map);
        -: 2218:            for (SizeType i = 0; i < data_.o.size; i++) {
        -: 2219:                map->erase(DropMapIterator(mit[i]));
        -: 2220:                members[i].~Member();
        -: 2221:            }
        -: 2222:            data_.o.size = 0;
        -: 2223:        }
        -: 2224:    }
        -: 2225:
        -: 2226:    void DoFreeMembers() {
        -: 2227:        if (Member* members = GetMembersPointer()) {
        -: 2228:            GetMap(members)->~Map();
        -: 2229:            for (SizeType i = 0; i < data_.o.size; i++) {
        -: 2230:                members[i].~Member();
        -: 2231:            }
        -: 2232:            if (Allocator::kNeedFree) { // Shortcut by Allocator's trait
        -: 2233:                Map** map = &GetMap(members);
        -: 2234:                Allocator::Free(*map);
        -: 2235:                Allocator::Free(map);
        -: 2236:            }
        -: 2237:        }
        -: 2238:    }
        -: 2239:
        -: 2240:#else // !RAPIDJSON_USE_MEMBERSMAP
        -: 2241:
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE14DoAllocMembersEjRS5_ called 1638 returned 100% blocks executed 100%
     1638: 2242:    RAPIDJSON_FORCEINLINE Member* DoAllocMembers(SizeType capacity, Allocator& allocator) {
     1638: 2243:        return Malloc<Member>(allocator, capacity);
     1638: 2243-block  0
call    0 returned 1638
        -: 2244:    }
        -: 2245:
        -: 2246:    void DoReserveMembers(SizeType newCapacity, Allocator& allocator) {
        -: 2247:        ObjectData& o = data_.o;
        -: 2248:        if (newCapacity > o.capacity) {
        -: 2249:            Member* newMembers = Realloc<Member>(allocator, GetMembersPointer(), o.capacity, newCapacity);
        -: 2250:            RAPIDJSON_SETPOINTER(Member, o.members, newMembers);
        -: 2251:            o.capacity = newCapacity;
        -: 2252:        }
        -: 2253:    }
        -: 2254:
        -: 2255:    template <typename SourceAllocator>
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE12DoFindMemberIS5_EENS_21GenericMemberIteratorILb0ES2_S5_EERKNS0_IS2_T_EE called 249 returned 100% blocks executed 100%
      249: 2256:    MemberIterator DoFindMember(const GenericValue<Encoding, SourceAllocator>& name) {
      249: 2257:        MemberIterator member = MemberBegin();
      249: 2257-block  0
call    0 returned 249
      449: 2258:        for ( ; member != MemberEnd(); ++member)
      449: 2258-block  0
call    0 returned 449
call    1 returned 449
branch  2 taken 449 (fallthrough)
branch  3 taken 0
      200: 2258-block  1
call    4 returned 200
      449: 2259:            if (name.StringEqual(member->name))
      449: 2259-block  0
call    0 returned 449
call    1 returned 449
branch  2 taken 249 (fallthrough)
branch  3 taken 200
      249: 2260:                break;
      249: 2260-block  0
      249: 2261:        return member;
      249: 2261-block  0
        -: 2262:    }
        -: 2263:
        -: 2264:    void DoClearMembers() {
        -: 2265:        for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)
        -: 2266:            m->~Member();
        -: 2267:        data_.o.size = 0;
        -: 2268:    }
        -: 2269:
        -: 2270:    void DoFreeMembers() {
        -: 2271:        for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)
        -: 2272:            m->~Member();
        -: 2273:        Allocator::Free(GetMembersPointer());
        -: 2274:    }
        -: 2275:
        -: 2276:#endif // !RAPIDJSON_USE_MEMBERSMAP
        -: 2277:
        -: 2278:    void DoAddMember(GenericValue& name, GenericValue& value, Allocator& allocator) {
        -: 2279:        ObjectData& o = data_.o;
        -: 2280:        if (o.size >= o.capacity)
        -: 2281:            DoReserveMembers(o.capacity ? (o.capacity + (o.capacity + 1) / 2) : kDefaultObjectCapacity, allocator);
        -: 2282:        Member* members = GetMembersPointer();
        -: 2283:        Member* m = members + o.size;
        -: 2284:        m->name.RawAssign(name);
        -: 2285:        m->value.RawAssign(value);
        -: 2286:#if RAPIDJSON_USE_MEMBERSMAP
        -: 2287:        Map* &map = GetMap(members);
        -: 2288:        MapIterator* mit = GetMapIterators(map);
        -: 2289:        new (&mit[o.size]) MapIterator(map->insert(MapPair(m->name.data_, o.size)));
        -: 2290:#endif
        -: 2291:        ++o.size;
        -: 2292:    }
        -: 2293:
        -: 2294:    MemberIterator DoRemoveMember(MemberIterator m) {
        -: 2295:        ObjectData& o = data_.o;
        -: 2296:        Member* members = GetMembersPointer();
        -: 2297:#if RAPIDJSON_USE_MEMBERSMAP
        -: 2298:        Map* &map = GetMap(members);
        -: 2299:        MapIterator* mit = GetMapIterators(map);
        -: 2300:        SizeType mpos = static_cast<SizeType>(&*m - members);
        -: 2301:        map->erase(DropMapIterator(mit[mpos]));
        -: 2302:#endif
        -: 2303:        MemberIterator last(members + (o.size - 1));
        -: 2304:        if (o.size > 1 && m != last) {
        -: 2305:#if RAPIDJSON_USE_MEMBERSMAP
        -: 2306:            new (&mit[mpos]) MapIterator(DropMapIterator(mit[&*last - members]));
        -: 2307:            mit[mpos]->second = mpos;
        -: 2308:#endif
        -: 2309:            *m = *last; // Move the last one to this place
        -: 2310:        }
        -: 2311:        else {
        -: 2312:            m->~Member(); // Only one left, just destroy
        -: 2313:        }
        -: 2314:        --o.size;
        -: 2315:        return m;
        -: 2316:    }
        -: 2317:
        -: 2318:    MemberIterator DoEraseMembers(ConstMemberIterator first, ConstMemberIterator last) {
        -: 2319:        ObjectData& o = data_.o;
        -: 2320:        MemberIterator beg = MemberBegin(),
        -: 2321:                       pos = beg + (first - beg),
        -: 2322:                       end = MemberEnd();
        -: 2323:#if RAPIDJSON_USE_MEMBERSMAP
        -: 2324:        Map* &map = GetMap(GetMembersPointer());
        -: 2325:        MapIterator* mit = GetMapIterators(map);
        -: 2326:#endif
        -: 2327:        for (MemberIterator itr = pos; itr != last; ++itr) {
        -: 2328:#if RAPIDJSON_USE_MEMBERSMAP
        -: 2329:            map->erase(DropMapIterator(mit[itr - beg]));
        -: 2330:#endif
        -: 2331:            itr->~Member();
        -: 2332:        }
        -: 2333:#if RAPIDJSON_USE_MEMBERSMAP
        -: 2334:        if (first != last) {
        -: 2335:            // Move remaining members/iterators
        -: 2336:            MemberIterator next = pos + (last - first);
        -: 2337:            for (MemberIterator itr = pos; next != end; ++itr, ++next) {
        -: 2338:                std::memcpy(static_cast<void*>(&*itr), &*next, sizeof(Member));
        -: 2339:                SizeType mpos = static_cast<SizeType>(itr - beg);
        -: 2340:                new (&mit[mpos]) MapIterator(DropMapIterator(mit[next - beg]));
        -: 2341:                mit[mpos]->second = mpos;
        -: 2342:            }
        -: 2343:        }
        -: 2344:#else
        -: 2345:        std::memmove(static_cast<void*>(&*pos), &*last,
        -: 2346:                     static_cast<size_t>(end - last) * sizeof(Member));
        -: 2347:#endif
        -: 2348:        o.size -= static_cast<SizeType>(last - first);
        -: 2349:        return pos;
        -: 2350:    }
        -: 2351:
        -: 2352:    template <typename SourceAllocator>
        -: 2353:    void DoCopyMembers(const GenericValue<Encoding,SourceAllocator>& rhs, Allocator& allocator, bool copyConstStrings) {
        -: 2354:        RAPIDJSON_ASSERT(rhs.GetType() == kObjectType);
        -: 2355:
        -: 2356:        data_.f.flags = kObjectFlag;
        -: 2357:        SizeType count = rhs.data_.o.size;
        -: 2358:        Member* lm = DoAllocMembers(count, allocator);
        -: 2359:        const typename GenericValue<Encoding,SourceAllocator>::Member* rm = rhs.GetMembersPointer();
        -: 2360:#if RAPIDJSON_USE_MEMBERSMAP
        -: 2361:        Map* &map = GetMap(lm);
        -: 2362:        MapIterator* mit = GetMapIterators(map);
        -: 2363:#endif
        -: 2364:        for (SizeType i = 0; i < count; i++) {
        -: 2365:            new (&lm[i].name) GenericValue(rm[i].name, allocator, copyConstStrings);
        -: 2366:            new (&lm[i].value) GenericValue(rm[i].value, allocator, copyConstStrings);
        -: 2367:#if RAPIDJSON_USE_MEMBERSMAP
        -: 2368:            new (&mit[i]) MapIterator(map->insert(MapPair(lm[i].name.data_, i)));
        -: 2369:#endif
        -: 2370:        }
        -: 2371:        data_.o.size = data_.o.capacity = count;
        -: 2372:        SetMembersPointer(lm);
        -: 2373:    }
        -: 2374:
        -: 2375:    // Initialize this value as array with initial data, without calling destructor.
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE11SetArrayRawEPS6_jRS5_ called 1346 returned 100% blocks executed 100%
     1346: 2376:    void SetArrayRaw(GenericValue* values, SizeType count, Allocator& allocator) {
     1346: 2377:        data_.f.flags = kArrayFlag;
     1346: 2378:        if (count) {
     1346: 2378-block  0
branch  0 taken 628 (fallthrough)
branch  1 taken 718
      628: 2379:            GenericValue* e = static_cast<GenericValue*>(allocator.Malloc(count * sizeof(GenericValue)));
      628: 2379-block  0
call    0 returned 628
      628: 2380:            SetElementsPointer(e);
call    0 returned 628
      628: 2381:            std::memcpy(static_cast<void*>(e), values, count * sizeof(GenericValue));
        -: 2382:        }
        -: 2383:        else
      718: 2384:            SetElementsPointer(0);
      718: 2384-block  0
call    0 returned 718
     1346: 2385:        data_.a.size = data_.a.capacity = count;
     1346: 2386:    }
        -: 2387:
        -: 2388:    //! Initialize this value as object with initial data, without calling destructor.
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE12SetObjectRawEPNS_13GenericMemberIS2_S5_EEjRS5_ called 1821 returned 100% blocks executed 100%
     1821: 2389:    void SetObjectRaw(Member* members, SizeType count, Allocator& allocator) {
     1821: 2390:        data_.f.flags = kObjectFlag;
     1821: 2391:        if (count) {
     1821: 2391-block  0
branch  0 taken 1638 (fallthrough)
branch  1 taken 183
     1638: 2392:            Member* m = DoAllocMembers(count, allocator);
     1638: 2392-block  0
call    0 returned 1638
     1638: 2393:            SetMembersPointer(m);
call    0 returned 1638
     1638: 2394:            std::memcpy(static_cast<void*>(m), members, count * sizeof(Member));
        -: 2395:#if RAPIDJSON_USE_MEMBERSMAP
        -: 2396:            Map* &map = GetMap(m);
        -: 2397:            MapIterator* mit = GetMapIterators(map);
        -: 2398:            for (SizeType i = 0; i < count; i++) {
        -: 2399:                new (&mit[i]) MapIterator(map->insert(MapPair(m[i].name.data_, i)));
        -: 2400:            }
        -: 2401:#endif
        -: 2402:        }
        -: 2403:        else
      183: 2404:            SetMembersPointer(0);
      183: 2404-block  0
call    0 returned 183
     1821: 2405:        data_.o.size = data_.o.capacity = count;
     1821: 2406:    }
        -: 2407:
        -: 2408:    //! Initialize this value as constant string, without calling destructor.
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE12SetStringRawENS_16GenericStringRefIcEE called 249 returned 100% blocks executed 100%
      249: 2409:    void SetStringRaw(StringRefType s) RAPIDJSON_NOEXCEPT {
      249: 2410:        data_.f.flags = kConstStringFlag;
      249: 2411:        SetStringPointer(s);
      249: 2411-block  0
call    0 returned 249
call    1 returned 249
      249: 2412:        data_.s.length = s.length;
      249: 2413:    }
        -: 2414:
        -: 2415:    //! Initialize this value as copy string with initial data, without calling destructor.
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE12SetStringRawENS_16GenericStringRefIcEERS5_ called 12824 returned 100% blocks executed 100%
    12824: 2416:    void SetStringRaw(StringRefType s, Allocator& allocator) {
    12824: 2417:        Ch* str = 0;
    12824: 2418:        if (ShortString::Usable(s.length)) {
    12824: 2418-block  0
call    0 returned 12824
branch  1 taken 12187 (fallthrough)
branch  2 taken 637
    12187: 2419:            data_.f.flags = kShortStringFlag;
    12187: 2420:            data_.ss.SetLength(s.length);
    12187: 2420-block  0
call    0 returned 12187
    12187: 2421:            str = data_.ss.str;
        -: 2422:        } else {
      637: 2423:            data_.f.flags = kCopyStringFlag;
      637: 2424:            data_.s.length = s.length;
      637: 2425:            str = static_cast<Ch *>(allocator.Malloc((s.length + 1) * sizeof(Ch)));
      637: 2425-block  0
call    0 returned 637
      637: 2426:            SetStringPointer(str);
call    0 returned 637
        -: 2427:        }
    12824: 2428:        std::memcpy(str, s, s.length * sizeof(Ch));
    12824: 2428-block  0
call    0 returned 12824
    12824: 2429:        str[s.length] = '\0';
    12824: 2430:    }
        -: 2431:
        -: 2432:    //! Assignment without calling destructor
function _ZN9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE9RawAssignERS6_ called 10 returned 100% blocks executed 100%
       10: 2433:    void RawAssign(GenericValue& rhs) RAPIDJSON_NOEXCEPT {
       10: 2434:        data_ = rhs.data_;
        -: 2435:        // data_.f.flags = rhs.data_.f.flags;
       10: 2436:        rhs.data_.f.flags = kNullFlag;
       10: 2437:    }
        -: 2438:
        -: 2439:    template <typename SourceAllocator>
function _ZNK9rapidjson12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEE11StringEqualIS5_EEbRKNS0_IS2_T_EE called 449 returned 100% blocks executed 81%
      449: 2440:    bool StringEqual(const GenericValue<Encoding, SourceAllocator>& rhs) const {
     449*: 2441:        RAPIDJSON_ASSERT(IsString());
      449: 2441-block  0
call    0 returned 449
branch  1 taken 0 (fallthrough)
branch  2 taken 449
    %%%%%: 2441-block  1
call    3 never executed
     449*: 2442:        RAPIDJSON_ASSERT(rhs.IsString());
      449: 2442-block  0
call    0 returned 449
branch  1 taken 0 (fallthrough)
branch  2 taken 449
    %%%%%: 2442-block  1
call    3 never executed
        -: 2443:
      449: 2444:        const SizeType len1 = GetStringLength();
      449: 2444-block  0
call    0 returned 449
      449: 2445:        const SizeType len2 = rhs.GetStringLength();
call    0 returned 449
      449: 2446:        if(len1 != len2) { return false; }
branch  0 taken 155 (fallthrough)
branch  1 taken 294
      155: 2446-block  0
        -: 2447:
      294: 2448:        const Ch* const str1 = GetString();
      294: 2448-block  0
call    0 returned 294
      294: 2449:        const Ch* const str2 = rhs.GetString();
call    0 returned 294
     294*: 2450:        if(str1 == str2) { return true; } // fast path for constant string
branch  0 taken 0 (fallthrough)
branch  1 taken 294
    %%%%%: 2450-block  0
        -: 2451:
      294: 2452:        return (std::memcmp(str1, str2, sizeof(Ch) * len1) == 0);
      294: 2452-block  0
        -: 2453:    }
        -: 2454:
        -: 2455:    Data data_;
        -: 2456:};
        -: 2457:
        -: 2458://! GenericValue with UTF8 encoding
        -: 2459:typedef GenericValue<UTF8<> > Value;
        -: 2460:
        -: 2461:///////////////////////////////////////////////////////////////////////////////
        -: 2462:// GenericDocument 
        -: 2463:
        -: 2464://! A document for parsing JSON text as DOM.
        -: 2465:/*!
        -: 2466:    \note implements Handler concept
        -: 2467:    \tparam Encoding Encoding for both parsing and string storage.
        -: 2468:    \tparam Allocator Allocator for allocating memory for the DOM
        -: 2469:    \tparam StackAllocator Allocator for allocating memory for stack during parsing.
        -: 2470:    \warning Although GenericDocument inherits from GenericValue, the API does \b not provide any virtual functions, especially no virtual destructor.  To avoid memory leaks, do not \c delete a GenericDocument object via a pointer to a GenericValue.
        -: 2471:*/
        -: 2472:template <typename Encoding, typename Allocator = RAPIDJSON_DEFAULT_ALLOCATOR, typename StackAllocator = RAPIDJSON_DEFAULT_STACK_ALLOCATOR >
        -: 2473:class GenericDocument : public GenericValue<Encoding, Allocator> {
        -: 2474:public:
        -: 2475:    typedef typename Encoding::Ch Ch;                       //!< Character type derived from Encoding.
        -: 2476:    typedef GenericValue<Encoding, Allocator> ValueType;    //!< Value type of the document.
        -: 2477:    typedef Allocator AllocatorType;                        //!< Allocator type from template parameter.
        -: 2478:
        -: 2479:    //! Constructor
        -: 2480:    /*! Creates an empty document of specified type.
        -: 2481:        \param type             Mandatory type of object to create.
        -: 2482:        \param allocator        Optional allocator for allocating memory.
        -: 2483:        \param stackCapacity    Optional initial capacity of stack in bytes.
        -: 2484:        \param stackAllocator   Optional allocator for allocating memory for stack.
        -: 2485:    */
        -: 2486:    explicit GenericDocument(Type type, Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :
        -: 2487:        GenericValue<Encoding, Allocator>(type),  allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
        -: 2488:    {
        -: 2489:        if (!allocator_)
        -: 2490:            ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
        -: 2491:    }
        -: 2492:
        -: 2493:    //! Constructor
        -: 2494:    /*! Creates an empty document which type is Null. 
        -: 2495:        \param allocator        Optional allocator for allocating memory.
        -: 2496:        \param stackCapacity    Optional initial capacity of stack in bytes.
        -: 2497:        \param stackAllocator   Optional allocator for allocating memory for stack.
        -: 2498:    */
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_EC2EPS5_mPS4_ called 5 returned 100% blocks executed 64%
        5: 2499:    GenericDocument(Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) : 
        5: 2500:        allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
        5: 2500-block  0
call    0 returned 5
call    1 returned 5
call    2 returned 5
    $$$$$: 2500-block  1
call    3 never executed
    $$$$$: 2500-block  2
call    4 never executed
        -: 2501:    {
        5: 2502:        if (!allocator_)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 2503:            ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
        5: 2503-block  0
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
        5: 2503-block  1
call    3 returned 5
branch  4 taken 5 (fallthrough)
branch  5 taken 0 (throw)
        5: 2503-block  2
    $$$$$: 2503-block  3
call    6 never executed
        5: 2504:    }
        5: 2504-block  0
        -: 2505:
        -: 2506:#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -: 2507:    //! Move constructor in C++11
        -: 2508:    GenericDocument(GenericDocument&& rhs) RAPIDJSON_NOEXCEPT
        -: 2509:        : ValueType(std::forward<ValueType>(rhs)), // explicit cast to avoid prohibited move from Document
        -: 2510:          allocator_(rhs.allocator_),
        -: 2511:          ownAllocator_(rhs.ownAllocator_),
        -: 2512:          stack_(std::move(rhs.stack_)),
        -: 2513:          parseResult_(rhs.parseResult_)
        -: 2514:    {
        -: 2515:        rhs.allocator_ = 0;
        -: 2516:        rhs.ownAllocator_ = 0;
        -: 2517:        rhs.parseResult_ = ParseResult();
        -: 2518:    }
        -: 2519:#endif
        -: 2520:
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_ED2Ev called 5 returned 100% blocks executed 100%
        5: 2521:    ~GenericDocument() {
        -: 2522:        // Clear the ::ValueType before ownAllocator is destroyed, ~ValueType()
        -: 2523:        // runs last and may access its elements or members which would be freed
        -: 2524:        // with an allocator like MemoryPoolAllocator (CrtAllocator does not
        -: 2525:        // free its data when destroyed, but MemoryPoolAllocator does).
        5: 2526:        if (ownAllocator_) {
        5: 2526-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 2527:            ValueType::SetNull();
        5: 2527-block  0
call    0 returned 5
        -: 2528:        }
        5: 2529:        Destroy();
        5: 2529-block  0
call    0 returned 5
        5: 2530:    }
call    0 returned 5
call    1 returned 5
        -: 2531:
        -: 2532:#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -: 2533:    //! Move assignment in C++11
        -: 2534:    GenericDocument& operator=(GenericDocument&& rhs) RAPIDJSON_NOEXCEPT
        -: 2535:    {
        -: 2536:        // The cast to ValueType is necessary here, because otherwise it would
        -: 2537:        // attempt to call GenericValue's templated assignment operator.
        -: 2538:        ValueType::operator=(std::forward<ValueType>(rhs));
        -: 2539:
        -: 2540:        // Calling the destructor here would prematurely call stack_'s destructor
        -: 2541:        Destroy();
        -: 2542:
        -: 2543:        allocator_ = rhs.allocator_;
        -: 2544:        ownAllocator_ = rhs.ownAllocator_;
        -: 2545:        stack_ = std::move(rhs.stack_);
        -: 2546:        parseResult_ = rhs.parseResult_;
        -: 2547:
        -: 2548:        rhs.allocator_ = 0;
        -: 2549:        rhs.ownAllocator_ = 0;
        -: 2550:        rhs.parseResult_ = ParseResult();
        -: 2551:
        -: 2552:        return *this;
        -: 2553:    }
        -: 2554:#endif
        -: 2555:
        -: 2556:    //! Exchange the contents of this document with those of another.
        -: 2557:    /*!
        -: 2558:        \param rhs Another document.
        -: 2559:        \note Constant complexity.
        -: 2560:        \see GenericValue::Swap
        -: 2561:    */
        -: 2562:    GenericDocument& Swap(GenericDocument& rhs) RAPIDJSON_NOEXCEPT {
        -: 2563:        ValueType::Swap(rhs);
        -: 2564:        stack_.Swap(rhs.stack_);
        -: 2565:        internal::Swap(allocator_, rhs.allocator_);
        -: 2566:        internal::Swap(ownAllocator_, rhs.ownAllocator_);
        -: 2567:        internal::Swap(parseResult_, rhs.parseResult_);
        -: 2568:        return *this;
        -: 2569:    }
        -: 2570:
        -: 2571:    // Allow Swap with ValueType.
        -: 2572:    // Refer to Effective C++ 3rd Edition/Item 33: Avoid hiding inherited names.
        -: 2573:    using ValueType::Swap;
        -: 2574:
        -: 2575:    //! free-standing swap function helper
        -: 2576:    /*!
        -: 2577:        Helper function to enable support for common swap implementation pattern based on \c std::swap:
        -: 2578:        \code
        -: 2579:        void swap(MyClass& a, MyClass& b) {
        -: 2580:            using std::swap;
        -: 2581:            swap(a.doc, b.doc);
        -: 2582:            // ...
        -: 2583:        }
        -: 2584:        \endcode
        -: 2585:        \see Swap()
        -: 2586:     */
        -: 2587:    friend inline void swap(GenericDocument& a, GenericDocument& b) RAPIDJSON_NOEXCEPT { a.Swap(b); }
        -: 2588:
        -: 2589:    //! Populate this document by a generator which produces SAX events.
        -: 2590:    /*! \tparam Generator A functor with <tt>bool f(Handler)</tt> prototype.
        -: 2591:        \param g Generator functor which sends SAX events to the parameter.
        -: 2592:        \return The document itself for fluent API.
        -: 2593:    */
        -: 2594:    template <typename Generator>
        -: 2595:    GenericDocument& Populate(Generator& g) {
        -: 2596:        ClearStackOnExit scope(*this);
        -: 2597:        if (g(*this)) {
        -: 2598:            RAPIDJSON_ASSERT(stack_.GetSize() == sizeof(ValueType)); // Got one and only one root object
        -: 2599:            ValueType::operator=(*stack_.template Pop<ValueType>(1));// Move value from stack to document
        -: 2600:        }
        -: 2601:        return *this;
        -: 2602:    }
        -: 2603:
        -: 2604:    //!@name Parse from stream
        -: 2605:    //!@{
        -: 2606:
        -: 2607:    //! Parse JSON text from an input stream (with Encoding conversion)
        -: 2608:    /*! \tparam parseFlags Combination of \ref ParseFlag.
        -: 2609:        \tparam SourceEncoding Encoding of input stream
        -: 2610:        \tparam InputStream Type of input stream, implementing Stream concept
        -: 2611:        \param is Input stream to be parsed.
        -: 2612:        \return The document itself for fluent API.
        -: 2613:    */
        -: 2614:    template <unsigned parseFlags, typename SourceEncoding, typename InputStream>
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E11ParseStreamILj0ES2_NS_19GenericStringStreamIS2_EEEERS6_RT1_ called 5 returned 100% blocks executed 74%
        5: 2615:    GenericDocument& ParseStream(InputStream& is) {
       10: 2616:        GenericReader<SourceEncoding, Encoding, StackAllocator> reader(
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        5: 2616-block  0
        5: 2616-block  1
call    2 returned 5
call    3 returned 5
    $$$$$: 2616-block  2
call    4 never executed
       5*: 2617:            stack_.HasAllocator() ? &stack_.GetAllocator() : 0);
        5: 2617-block  0
call    0 returned 5
    %%%%%: 2617-block  1
call    1 never executed
        5: 2618:        ClearStackOnExit scope(*this);
call    0 returned 5
    $$$$$: 2618-block  0
call    1 never executed
        5: 2619:        parseResult_ = reader.template Parse<parseFlags>(is, *this);
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
        5: 2620:        if (parseResult_) {
        5: 2620-block  0
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
        5: 2620-block  1
branch  3 taken 5 (fallthrough)
branch  4 taken 0
       5*: 2621:            RAPIDJSON_ASSERT(stack_.GetSize() == sizeof(ValueType)); // Got one and only one root object
        5: 2621-block  0
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    %%%%%: 2621-block  1
call    3 never executed
        5: 2622:            ValueType::operator=(*stack_.template Pop<ValueType>(1));// Move value from stack to document
        5: 2622-block  0
call    0 returned 5
call    1 returned 5
        -: 2623:        }
       10: 2624:        return *this;
        5: 2624-block  0
call    0 returned 5
        5: 2624-block  1
        -: 2625:    }
        -: 2626:
        -: 2627:    //! Parse JSON text from an input stream
        -: 2628:    /*! \tparam parseFlags Combination of \ref ParseFlag.
        -: 2629:        \tparam InputStream Type of input stream, implementing Stream concept
        -: 2630:        \param is Input stream to be parsed.
        -: 2631:        \return The document itself for fluent API.
        -: 2632:    */
        -: 2633:    template <unsigned parseFlags, typename InputStream>
        -: 2634:    GenericDocument& ParseStream(InputStream& is) {
        -: 2635:        return ParseStream<parseFlags, Encoding, InputStream>(is);
        -: 2636:    }
        -: 2637:
        -: 2638:    //! Parse JSON text from an input stream (with \ref kParseDefaultFlags)
        -: 2639:    /*! \tparam InputStream Type of input stream, implementing Stream concept
        -: 2640:        \param is Input stream to be parsed.
        -: 2641:        \return The document itself for fluent API.
        -: 2642:    */
        -: 2643:    template <typename InputStream>
        -: 2644:    GenericDocument& ParseStream(InputStream& is) {
        -: 2645:        return ParseStream<kParseDefaultFlags, Encoding, InputStream>(is);
        -: 2646:    }
        -: 2647:    //!@}
        -: 2648:
        -: 2649:    //!@name Parse in-place from mutable string
        -: 2650:    //!@{
        -: 2651:
        -: 2652:    //! Parse JSON text from a mutable string
        -: 2653:    /*! \tparam parseFlags Combination of \ref ParseFlag.
        -: 2654:        \param str Mutable zero-terminated string to be parsed.
        -: 2655:        \return The document itself for fluent API.
        -: 2656:    */
        -: 2657:    template <unsigned parseFlags>
        -: 2658:    GenericDocument& ParseInsitu(Ch* str) {
        -: 2659:        GenericInsituStringStream<Encoding> s(str);
        -: 2660:        return ParseStream<parseFlags | kParseInsituFlag>(s);
        -: 2661:    }
        -: 2662:
        -: 2663:    //! Parse JSON text from a mutable string (with \ref kParseDefaultFlags)
        -: 2664:    /*! \param str Mutable zero-terminated string to be parsed.
        -: 2665:        \return The document itself for fluent API.
        -: 2666:    */
        -: 2667:    GenericDocument& ParseInsitu(Ch* str) {
        -: 2668:        return ParseInsitu<kParseDefaultFlags>(str);
        -: 2669:    }
        -: 2670:    //!@}
        -: 2671:
        -: 2672:    //!@name Parse from read-only string
        -: 2673:    //!@{
        -: 2674:
        -: 2675:    //! Parse JSON text from a read-only string (with Encoding conversion)
        -: 2676:    /*! \tparam parseFlags Combination of \ref ParseFlag (must not contain \ref kParseInsituFlag).
        -: 2677:        \tparam SourceEncoding Transcoding from input Encoding
        -: 2678:        \param str Read-only zero-terminated string to be parsed.
        -: 2679:    */
        -: 2680:    template <unsigned parseFlags, typename SourceEncoding>
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E5ParseILj0ES2_EERS6_PKNT0_2ChE called 5 returned 100% blocks executed 100%
        5: 2681:    GenericDocument& Parse(const typename SourceEncoding::Ch* str) {
        -: 2682:        RAPIDJSON_ASSERT(!(parseFlags & kParseInsituFlag));
        5: 2683:        GenericStringStream<SourceEncoding> s(str);
        5: 2683-block  0
call    0 returned 5
        5: 2684:        return ParseStream<parseFlags, SourceEncoding>(s);
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
        5: 2684-block  0
        5: 2684-block  1
        -: 2685:    }
        -: 2686:
        -: 2687:    //! Parse JSON text from a read-only string
        -: 2688:    /*! \tparam parseFlags Combination of \ref ParseFlag (must not contain \ref kParseInsituFlag).
        -: 2689:        \param str Read-only zero-terminated string to be parsed.
        -: 2690:    */
        -: 2691:    template <unsigned parseFlags>
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E5ParseILj0EEERS6_PKc called 5 returned 100% blocks executed 100%
        5: 2692:    GenericDocument& Parse(const Ch* str) {
        5: 2693:        return Parse<parseFlags, Encoding>(str);
        5: 2693-block  0
call    0 returned 5
        -: 2694:    }
        -: 2695:
        -: 2696:    //! Parse JSON text from a read-only string (with \ref kParseDefaultFlags)
        -: 2697:    /*! \param str Read-only zero-terminated string to be parsed.
        -: 2698:    */
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E5ParseEPKc called 5 returned 100% blocks executed 100%
        5: 2699:    GenericDocument& Parse(const Ch* str) {
        5: 2700:        return Parse<kParseDefaultFlags>(str);
        5: 2700-block  0
call    0 returned 5
        -: 2701:    }
        -: 2702:
        -: 2703:    template <unsigned parseFlags, typename SourceEncoding>
        -: 2704:    GenericDocument& Parse(const typename SourceEncoding::Ch* str, size_t length) {
        -: 2705:        RAPIDJSON_ASSERT(!(parseFlags & kParseInsituFlag));
        -: 2706:        MemoryStream ms(reinterpret_cast<const char*>(str), length * sizeof(typename SourceEncoding::Ch));
        -: 2707:        EncodedInputStream<SourceEncoding, MemoryStream> is(ms);
        -: 2708:        ParseStream<parseFlags, SourceEncoding>(is);
        -: 2709:        return *this;
        -: 2710:    }
        -: 2711:
        -: 2712:    template <unsigned parseFlags>
        -: 2713:    GenericDocument& Parse(const Ch* str, size_t length) {
        -: 2714:        return Parse<parseFlags, Encoding>(str, length);
        -: 2715:    }
        -: 2716:    
        -: 2717:    GenericDocument& Parse(const Ch* str, size_t length) {
        -: 2718:        return Parse<kParseDefaultFlags>(str, length);
        -: 2719:    }
        -: 2720:
        -: 2721:#if RAPIDJSON_HAS_STDSTRING
        -: 2722:    template <unsigned parseFlags, typename SourceEncoding>
        -: 2723:    GenericDocument& Parse(const std::basic_string<typename SourceEncoding::Ch>& str) {
        -: 2724:        // c_str() is constant complexity according to standard. Should be faster than Parse(const char*, size_t)
        -: 2725:        return Parse<parseFlags, SourceEncoding>(str.c_str());
        -: 2726:    }
        -: 2727:
        -: 2728:    template <unsigned parseFlags>
        -: 2729:    GenericDocument& Parse(const std::basic_string<Ch>& str) {
        -: 2730:        return Parse<parseFlags, Encoding>(str.c_str());
        -: 2731:    }
        -: 2732:
        -: 2733:    GenericDocument& Parse(const std::basic_string<Ch>& str) {
        -: 2734:        return Parse<kParseDefaultFlags>(str);
        -: 2735:    }
        -: 2736:#endif // RAPIDJSON_HAS_STDSTRING    
        -: 2737:
        -: 2738:    //!@}
        -: 2739:
        -: 2740:    //!@name Handling parse errors
        -: 2741:    //!@{
        -: 2742:
        -: 2743:    //! Whether a parse error has occurred in the last parsing.
        -: 2744:    bool HasParseError() const { return parseResult_.IsError(); }
        -: 2745:
        -: 2746:    //! Get the \ref ParseErrorCode of last parsing.
        -: 2747:    ParseErrorCode GetParseError() const { return parseResult_.Code(); }
        -: 2748:
        -: 2749:    //! Get the position of last parsing error in input, 0 otherwise.
        -: 2750:    size_t GetErrorOffset() const { return parseResult_.Offset(); }
        -: 2751:
        -: 2752:    //! Implicit conversion to get the last parse result
        -: 2753:#ifndef __clang // -Wdocumentation
        -: 2754:    /*! \return \ref ParseResult of the last parse operation
        -: 2755:
        -: 2756:        \code
        -: 2757:          Document doc;
        -: 2758:          ParseResult ok = doc.Parse(json);
        -: 2759:          if (!ok)
        -: 2760:            printf( "JSON parse error: %s (%u)\n", GetParseError_En(ok.Code()), ok.Offset());
        -: 2761:        \endcode
        -: 2762:     */
        -: 2763:#endif
        -: 2764:    operator ParseResult() const { return parseResult_; }
        -: 2765:    //!@}
        -: 2766:
        -: 2767:    //! Get the allocator of this document.
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E12GetAllocatorEv called 15991 returned 100% blocks executed 75%
    15991: 2768:    Allocator& GetAllocator() {
   15991*: 2769:        RAPIDJSON_ASSERT(allocator_);
    15991: 2769-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15991
    %%%%%: 2769-block  1
call    2 never executed
    15991: 2770:        return *allocator_;
    15991: 2770-block  0
        -: 2771:    }
        -: 2772:
        -: 2773:    //! Get the capacity of stack in bytes.
        -: 2774:    size_t GetStackCapacity() const { return stack_.GetCapacity(); }
        -: 2775:
        -: 2776:private:
        -: 2777:    // clear stack on any exit from ParseStream, e.g. due to exception
        -: 2778:    struct ClearStackOnExit {
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E16ClearStackOnExitC2ERS6_ called 5 returned 100% blocks executed 100%
        5: 2779:        explicit ClearStackOnExit(GenericDocument& d) : d_(d) {}
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E16ClearStackOnExitD2Ev called 5 returned 100% blocks executed 100%
        5: 2780:        ~ClearStackOnExit() { d_.ClearStack(); }
        5: 2780-block  0
call    0 returned 5
        -: 2781:    private:
        -: 2782:        ClearStackOnExit(const ClearStackOnExit&);
        -: 2783:        ClearStackOnExit& operator=(const ClearStackOnExit&);
        -: 2784:        GenericDocument& d_;
        -: 2785:    };
        -: 2786:
        -: 2787:    // callers of the following private Handler functions
        -: 2788:    // template <typename,typename,typename> friend class GenericReader; // for parsing
        -: 2789:    template <typename, typename> friend class GenericValue; // for deep copying
        -: 2790:
        -: 2791:public:
        -: 2792:    // Implementation of Handler
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E4NullEv called 55 returned 100% blocks executed 100%
      110: 2793:    bool Null() { new (stack_.template Push<ValueType>()) ValueType(); return true; }
       55: 2793-block  0
call    0 returned 55
call    1 returned 55
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E4BoolEb called 0 returned 0% blocks executed 0%
    #####: 2794:    bool Bool(bool b) { new (stack_.template Push<ValueType>()) ValueType(b); return true; }
    %%%%%: 2794-block  0
call    0 never executed
call    1 never executed
call    2 never executed
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E3IntEi called 0 returned 0% blocks executed 0%
    #####: 2795:    bool Int(int i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
    %%%%%: 2795-block  0
call    0 never executed
call    1 never executed
call    2 never executed
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E4UintEj called 847 returned 100% blocks executed 100%
      847: 2796:    bool Uint(unsigned i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
      847: 2796-block  0
call    0 returned 847
call    1 returned 847
call    2 returned 847
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E5Int64El called 0 returned 0% blocks executed 0%
    #####: 2797:    bool Int64(int64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
    %%%%%: 2797-block  0
call    0 never executed
call    1 never executed
call    2 never executed
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E6Uint64Em called 0 returned 0% blocks executed 0%
    #####: 2798:    bool Uint64(uint64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
    %%%%%: 2798-block  0
call    0 never executed
call    1 never executed
call    2 never executed
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E6DoubleEd called 0 returned 0% blocks executed 0%
    #####: 2799:    bool Double(double d) { new (stack_.template Push<ValueType>()) ValueType(d); return true; }
    %%%%%: 2799-block  0
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2800:
        -: 2801:    bool RawNumber(const Ch* str, SizeType length, bool copy) { 
        -: 2802:        if (copy) 
        -: 2803:            new (stack_.template Push<ValueType>()) ValueType(str, length, GetAllocator());
        -: 2804:        else
        -: 2805:            new (stack_.template Push<ValueType>()) ValueType(str, length);
        -: 2806:        return true;
        -: 2807:    }
        -: 2808:
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E6StringEPKcjb called 12824 returned 100% blocks executed 67%
    12824: 2809:    bool String(const Ch* str, SizeType length, bool copy) { 
    12824: 2810:        if (copy) 
    12824: 2810-block  0
branch  0 taken 12824 (fallthrough)
branch  1 taken 0
    12824: 2811:            new (stack_.template Push<ValueType>()) ValueType(str, length, GetAllocator());
    12824: 2811-block  0
call    0 returned 12824
call    1 returned 12824
call    2 returned 12824
call    3 returned 12824
branch  4 taken 12824 (fallthrough)
branch  5 taken 0 (throw)
    $$$$$: 2811-block  1
call    6 never executed
        -: 2812:        else
    #####: 2813:            new (stack_.template Push<ValueType>()) ValueType(str, length);
    %%%%%: 2813-block  0
call    0 never executed
call    1 never executed
call    2 never executed
    12824: 2814:        return true;
    12824: 2814-block  0
    12824: 2814-block  1
        -: 2815:    }
        -: 2816:
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E11StartObjectEv called 1821 returned 100% blocks executed 100%
     1821: 2817:    bool StartObject() { new (stack_.template Push<ValueType>()) ValueType(kObjectType); return true; }
     1821: 2817-block  0
call    0 returned 1821
call    1 returned 1821
call    2 returned 1821
        -: 2818:    
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E3KeyEPKcjb called 7637 returned 100% blocks executed 100%
     7637: 2819:    bool Key(const Ch* str, SizeType length, bool copy) { return String(str, length, copy); }
     7637: 2819-block  0
call    0 returned 7637
        -: 2820:
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E9EndObjectEj called 1821 returned 100% blocks executed 100%
     1821: 2821:    bool EndObject(SizeType memberCount) {
     1821: 2822:        typename ValueType::Member* members = stack_.template Pop<typename ValueType::Member>(memberCount);
     1821: 2822-block  0
call    0 returned 1821
     1821: 2823:        stack_.template Top<ValueType>()->SetObjectRaw(members, memberCount, GetAllocator());
call    0 returned 1821
call    1 returned 1821
call    2 returned 1821
     1821: 2824:        return true;
        -: 2825:    }
        -: 2826:
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E10StartArrayEv called 1346 returned 100% blocks executed 100%
     1346: 2827:    bool StartArray() { new (stack_.template Push<ValueType>()) ValueType(kArrayType); return true; }
     1346: 2827-block  0
call    0 returned 1346
call    1 returned 1346
call    2 returned 1346
        -: 2828:    
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E8EndArrayEj called 1346 returned 100% blocks executed 100%
     1346: 2829:    bool EndArray(SizeType elementCount) {
     1346: 2830:        ValueType* elements = stack_.template Pop<ValueType>(elementCount);
     1346: 2830-block  0
call    0 returned 1346
     1346: 2831:        stack_.template Top<ValueType>()->SetArrayRaw(elements, elementCount, GetAllocator());
call    0 returned 1346
call    1 returned 1346
call    2 returned 1346
     1346: 2832:        return true;
        -: 2833:    }
        -: 2834:
        -: 2835:private:
        -: 2836:    //! Prohibit copying
        -: 2837:    GenericDocument(const GenericDocument&);
        -: 2838:    //! Prohibit assignment
        -: 2839:    GenericDocument& operator=(const GenericDocument&);
        -: 2840:
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E10ClearStackEv called 5 returned 100% blocks executed 100%
        5: 2841:    void ClearStack() {
        5: 2841-block  0
        -: 2842:        if (Allocator::kNeedFree)
        -: 2843:            while (stack_.GetSize() > 0)    // Here assumes all elements in stack array are GenericValue (Member is actually 2 GenericValue objects)
        -: 2844:                (stack_.template Pop<ValueType>(1))->~ValueType();
        -: 2845:        else
        5: 2846:            stack_.Clear();
        5: 2846-block  0
call    0 returned 5
        5: 2847:        stack_.ShrinkToFit();
call    0 returned 5
        5: 2848:    }
        -: 2849:
function _ZN9rapidjson15GenericDocumentINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEES4_E7DestroyEv called 5 returned 100% blocks executed 100%
        5: 2850:    void Destroy() {
        5: 2851:        RAPIDJSON_DELETE(ownAllocator_);
        5: 2851-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 2851-block  1
call    2 returned 5
call    3 returned 5
        5: 2852:    }
        -: 2853:
        -: 2854:    static const size_t kDefaultStackCapacity = 1024;
        -: 2855:    Allocator* allocator_;
        -: 2856:    Allocator* ownAllocator_;
        -: 2857:    internal::Stack<StackAllocator> stack_;
        -: 2858:    ParseResult parseResult_;
        -: 2859:};
        -: 2860:
        -: 2861://! GenericDocument with UTF8 encoding
        -: 2862:typedef GenericDocument<UTF8<> > Document;
        -: 2863:
        -: 2864:
        -: 2865://! Helper class for accessing Value of array type.
        -: 2866:/*!
        -: 2867:    Instance of this helper class is obtained by \c GenericValue::GetArray().
        -: 2868:    In addition to all APIs for array type, it provides range-based for loop if \c RAPIDJSON_HAS_CXX11_RANGE_FOR=1.
        -: 2869:*/
        -: 2870:template <bool Const, typename ValueT>
        -: 2871:class GenericArray {
        -: 2872:public:
        -: 2873:    typedef GenericArray<true, ValueT> ConstArray;
        -: 2874:    typedef GenericArray<false, ValueT> Array;
        -: 2875:    typedef ValueT PlainType;
        -: 2876:    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
        -: 2877:    typedef ValueType* ValueIterator;  // This may be const or non-const iterator
        -: 2878:    typedef const ValueT* ConstValueIterator;
        -: 2879:    typedef typename ValueType::AllocatorType AllocatorType;
        -: 2880:    typedef typename ValueType::StringRefType StringRefType;
        -: 2881:
        -: 2882:    template <typename, typename>
        -: 2883:    friend class GenericValue;
        -: 2884:
        -: 2885:    GenericArray(const GenericArray& rhs) : value_(rhs.value_) {}
        -: 2886:    GenericArray& operator=(const GenericArray& rhs) { value_ = rhs.value_; return *this; }
function _ZN9rapidjson12GenericArrayILb0ENS_12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEEED2Ev called 15 returned 100% blocks executed 100%
       15: 2887:    ~GenericArray() {}
        -: 2888:
        -: 2889:    operator ValueType&() const { return value_; }
        -: 2890:    SizeType Size() const { return value_.Size(); }
        -: 2891:    SizeType Capacity() const { return value_.Capacity(); }
        -: 2892:    bool Empty() const { return value_.Empty(); }
        -: 2893:    void Clear() const { value_.Clear(); }
        -: 2894:    ValueType& operator[](SizeType index) const {  return value_[index]; }
        -: 2895:    ValueIterator Begin() const { return value_.Begin(); }
        -: 2896:    ValueIterator End() const { return value_.End(); }
        -: 2897:    GenericArray Reserve(SizeType newCapacity, AllocatorType &allocator) const { value_.Reserve(newCapacity, allocator); return *this; }
        -: 2898:    GenericArray PushBack(ValueType& value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
        -: 2899:#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -: 2900:    GenericArray PushBack(ValueType&& value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
        -: 2901:#endif // RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -: 2902:    GenericArray PushBack(StringRefType value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
        -: 2903:    template <typename T> RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (const GenericArray&)) PushBack(T value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
        -: 2904:    GenericArray PopBack() const { value_.PopBack(); return *this; }
        -: 2905:    ValueIterator Erase(ConstValueIterator pos) const { return value_.Erase(pos); }
        -: 2906:    ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) const { return value_.Erase(first, last); }
        -: 2907:
        -: 2908:#if RAPIDJSON_HAS_CXX11_RANGE_FOR
function _ZNK9rapidjson12GenericArrayILb0ENS_12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEEE5beginEv called 15 returned 100% blocks executed 100%
       15: 2909:    ValueIterator begin() const { return value_.Begin(); }
       15: 2909-block  0
call    0 returned 15
function _ZNK9rapidjson12GenericArrayILb0ENS_12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEEE3endEv called 15 returned 100% blocks executed 100%
       15: 2910:    ValueIterator end() const { return value_.End(); }
       15: 2910-block  0
call    0 returned 15
        -: 2911:#endif
        -: 2912:
        -: 2913:private:
        -: 2914:    GenericArray();
function _ZN9rapidjson12GenericArrayILb0ENS_12GenericValueINS_4UTF8IcEENS_19MemoryPoolAllocatorINS_12CrtAllocatorEEEEEEC2ERS7_ called 15 returned 100% blocks executed 100%
       15: 2915:    GenericArray(ValueType& value) : value_(value) {}
        -: 2916:    ValueType& value_;
        -: 2917:};
        -: 2918:
        -: 2919://! Helper class for accessing Value of object type.
        -: 2920:/*!
        -: 2921:    Instance of this helper class is obtained by \c GenericValue::GetObject().
        -: 2922:    In addition to all APIs for array type, it provides range-based for loop if \c RAPIDJSON_HAS_CXX11_RANGE_FOR=1.
        -: 2923:*/
        -: 2924:template <bool Const, typename ValueT>
        -: 2925:class GenericObject {
        -: 2926:public:
        -: 2927:    typedef GenericObject<true, ValueT> ConstObject;
        -: 2928:    typedef GenericObject<false, ValueT> Object;
        -: 2929:    typedef ValueT PlainType;
        -: 2930:    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
        -: 2931:    typedef GenericMemberIterator<Const, typename ValueT::EncodingType, typename ValueT::AllocatorType> MemberIterator;  // This may be const or non-const iterator
        -: 2932:    typedef GenericMemberIterator<true, typename ValueT::EncodingType, typename ValueT::AllocatorType> ConstMemberIterator;
        -: 2933:    typedef typename ValueType::AllocatorType AllocatorType;
        -: 2934:    typedef typename ValueType::StringRefType StringRefType;
        -: 2935:    typedef typename ValueType::EncodingType EncodingType;
        -: 2936:    typedef typename ValueType::Ch Ch;
        -: 2937:
        -: 2938:    template <typename, typename>
        -: 2939:    friend class GenericValue;
        -: 2940:
        -: 2941:    GenericObject(const GenericObject& rhs) : value_(rhs.value_) {}
        -: 2942:    GenericObject& operator=(const GenericObject& rhs) { value_ = rhs.value_; return *this; }
        -: 2943:    ~GenericObject() {}
        -: 2944:
        -: 2945:    operator ValueType&() const { return value_; }
        -: 2946:    SizeType MemberCount() const { return value_.MemberCount(); }
        -: 2947:    SizeType MemberCapacity() const { return value_.MemberCapacity(); }
        -: 2948:    bool ObjectEmpty() const { return value_.ObjectEmpty(); }
        -: 2949:    template <typename T> ValueType& operator[](T* name) const { return value_[name]; }
        -: 2950:    template <typename SourceAllocator> ValueType& operator[](const GenericValue<EncodingType, SourceAllocator>& name) const { return value_[name]; }
        -: 2951:#if RAPIDJSON_HAS_STDSTRING
        -: 2952:    ValueType& operator[](const std::basic_string<Ch>& name) const { return value_[name]; }
        -: 2953:#endif
        -: 2954:    MemberIterator MemberBegin() const { return value_.MemberBegin(); }
        -: 2955:    MemberIterator MemberEnd() const { return value_.MemberEnd(); }
        -: 2956:    GenericObject MemberReserve(SizeType newCapacity, AllocatorType &allocator) const { value_.MemberReserve(newCapacity, allocator); return *this; }
        -: 2957:    bool HasMember(const Ch* name) const { return value_.HasMember(name); }
        -: 2958:#if RAPIDJSON_HAS_STDSTRING
        -: 2959:    bool HasMember(const std::basic_string<Ch>& name) const { return value_.HasMember(name); }
        -: 2960:#endif
        -: 2961:    template <typename SourceAllocator> bool HasMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.HasMember(name); }
        -: 2962:    MemberIterator FindMember(const Ch* name) const { return value_.FindMember(name); }
        -: 2963:    template <typename SourceAllocator> MemberIterator FindMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.FindMember(name); }
        -: 2964:#if RAPIDJSON_HAS_STDSTRING
        -: 2965:    MemberIterator FindMember(const std::basic_string<Ch>& name) const { return value_.FindMember(name); }
        -: 2966:#endif
        -: 2967:    GenericObject AddMember(ValueType& name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2968:    GenericObject AddMember(ValueType& name, StringRefType value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2969:#if RAPIDJSON_HAS_STDSTRING
        -: 2970:    GenericObject AddMember(ValueType& name, std::basic_string<Ch>& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2971:#endif
        -: 2972:    template <typename T> RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&)) AddMember(ValueType& name, T value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2973:#if RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -: 2974:    GenericObject AddMember(ValueType&& name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2975:    GenericObject AddMember(ValueType&& name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2976:    GenericObject AddMember(ValueType& name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2977:    GenericObject AddMember(StringRefType name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2978:#endif // RAPIDJSON_HAS_CXX11_RVALUE_REFS
        -: 2979:    GenericObject AddMember(StringRefType name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2980:    GenericObject AddMember(StringRefType name, StringRefType value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2981:    template <typename T> RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericObject)) AddMember(StringRefType name, T value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
        -: 2982:    void RemoveAllMembers() { value_.RemoveAllMembers(); }
        -: 2983:    bool RemoveMember(const Ch* name) const { return value_.RemoveMember(name); }
        -: 2984:#if RAPIDJSON_HAS_STDSTRING
        -: 2985:    bool RemoveMember(const std::basic_string<Ch>& name) const { return value_.RemoveMember(name); }
        -: 2986:#endif
        -: 2987:    template <typename SourceAllocator> bool RemoveMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.RemoveMember(name); }
        -: 2988:    MemberIterator RemoveMember(MemberIterator m) const { return value_.RemoveMember(m); }
        -: 2989:    MemberIterator EraseMember(ConstMemberIterator pos) const { return value_.EraseMember(pos); }
        -: 2990:    MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) const { return value_.EraseMember(first, last); }
        -: 2991:    bool EraseMember(const Ch* name) const { return value_.EraseMember(name); }
        -: 2992:#if RAPIDJSON_HAS_STDSTRING
        -: 2993:    bool EraseMember(const std::basic_string<Ch>& name) const { return EraseMember(ValueType(StringRef(name))); }
        -: 2994:#endif
        -: 2995:    template <typename SourceAllocator> bool EraseMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.EraseMember(name); }
        -: 2996:
        -: 2997:#if RAPIDJSON_HAS_CXX11_RANGE_FOR
        -: 2998:    MemberIterator begin() const { return value_.MemberBegin(); }
        -: 2999:    MemberIterator end() const { return value_.MemberEnd(); }
        -: 3000:#endif
        -: 3001:
        -: 3002:private:
        -: 3003:    GenericObject();
        -: 3004:    GenericObject(ValueType& value) : value_(value) {}
        -: 3005:    ValueType& value_;
        -: 3006:};
        -: 3007:
        -: 3008:RAPIDJSON_NAMESPACE_END
        -: 3009:RAPIDJSON_DIAG_POP
        -: 3010:
        -: 3011:#endif // RAPIDJSON_DOCUMENT_H_
